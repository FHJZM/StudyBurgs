"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayoutType = exports.DrawStage = void 0;
var react_1 = __importDefault(require("react"));
var core_1 = require("./core");
var NOOP_SIZE = new core_1.Size(5, 5);
var DrawStage;
(function (DrawStage) {
    DrawStage[DrawStage["MEASURE_HIDDEN"] = 0] = "MEASURE_HIDDEN";
    DrawStage[DrawStage["MEASURE_VISIBLE"] = 1] = "MEASURE_VISIBLE";
    DrawStage[DrawStage["RENDER"] = 2] = "RENDER";
})(DrawStage = exports.DrawStage || (exports.DrawStage = {}));
var LayoutType;
(function (LayoutType) {
    LayoutType["LINEAR"] = "linear";
    LayoutType["SMART"] = "smart";
    LayoutType["FISHBONE_1"] = "fishbone1";
    LayoutType["FISHBONE_2"] = "fishbone2";
    LayoutType["FISHBONE_3"] = "fishbone3";
    LayoutType["FISHBONE_4"] = "fishbone4";
    LayoutType["SINGLE_COLUMN_RIGHT"] = "singleColumnRight";
    LayoutType["SINGLE_COLUMN_LEFT"] = "singleColumnLeft";
    LayoutType["STACKERS"] = "stackers";
    LayoutType["ASSISTANTS"] = "assistants";
})(LayoutType = exports.LayoutType || (exports.LayoutType = {}));
var OrgChartDiagram = /** @class */ (function (_super) {
    __extends(OrgChartDiagram, _super);
    function OrgChartDiagram(dataSource) {
        var _this = _super.call(this) || this;
        _this.DataSource = dataSource;
        return _this;
    }
    return OrgChartDiagram;
}(core_1.Diagram));
var Effect = function (props) {
    var onEffect = props.onEffect, children = props.children;
    if (typeof react_1.default.useEffect === "function" && typeof onEffect === "function") {
        react_1.default.useEffect(onEffect);
    }
    return children;
};
var OrgChart = /** @class */ (function (_super) {
    __extends(OrgChart, _super);
    function OrgChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lines: Array(),
            width: 0,
            height: 0,
            diagram: null,
            nodes: [],
            drawStage: DrawStage.MEASURE_HIDDEN,
            boundaries: [],
            prevProps: null,
            renderIndex: 0,
        };
        _this._mounted = true;
        _this._container = null;
        _this.onComputeBranchOptimizer = function (node) {
            var _a = _this.props.layout, layout = _a === void 0 ? LayoutType.LINEAR : _a;
            if (node.IsAssistantRoot) {
                var _b = _this.props.assistantLayout, assistantLayout = _b === void 0 ? LayoutType.ASSISTANTS : _b;
                if (assistantLayout instanceof core_1.LayoutStrategyBase) {
                    return "assistantCustom";
                }
                else {
                    return assistantLayout;
                }
            }
            else if (layout === "smart") {
                return OrgChart.getBranchOptimizerSmart(node);
            }
            else if (layout === "stackers") {
                return OrgChart.getBranchOptimizerStackers(node);
            }
            else if (layout instanceof core_1.LayoutStrategyBase) {
                return "custom";
            }
            else {
                return layout;
            }
        };
        _this._tid = null;
        _this._lastRenderIndex = 0;
        _this.safelyDrawDiagram = function () {
            if (_this.props !== _this.state.prevProps) {
                // this.setState({});
                return;
            }
            if (!_this._mounted) {
                return;
            }
            var _a = _this.state, diagram = _a.diagram, renderIndex = _a.renderIndex;
            var _b = _this.props, debug = _b.debug, _c = _b.measureTimeoutDelay, measureTimeoutDelay = _c === void 0 ? 0 : _c, _d = _b.measureStrategy, measureStrategy = _d === void 0 ? "timeout" : _d;
            if (renderIndex > _this._lastRenderIndex) {
                _this._lastRenderIndex = renderIndex;
                if (diagram) {
                    var onDOMUpdateComplete = function () {
                        if (_this._lastRenderIndex !== renderIndex) {
                            return;
                        }
                        _this.drawDiagram(diagram, debug);
                    };
                    if (measureStrategy === "effect" || measureStrategy === "immediate") {
                        // call immediately since it's invoked by the effect strategy
                        onDOMUpdateComplete();
                    }
                    else if (measureStrategy === "idle") {
                        // @ts-ignore
                        window.cancelIdleCallback(_this._tid);
                        // @ts-ignore
                        _this._tid = window.requestIdleCallback(onDOMUpdateComplete);
                    }
                    else if (measureStrategy === "animation-frame") {
                        window.cancelAnimationFrame(_this._tid);
                        _this._tid = window.requestAnimationFrame(onDOMUpdateComplete);
                    }
                    else {
                        clearTimeout(_this._tid);
                        _this._tid = setTimeout(onDOMUpdateComplete, measureTimeoutDelay);
                    }
                }
            }
        };
        _this.componentDidMount = (_this.componentDidUpdate = function () {
            var measureStrategy = _this.props.measureStrategy;
            if (measureStrategy !== "effect") {
                _this.safelyDrawDiagram();
            }
        });
        return _this;
    }
    OrgChart.assignStrategies = function (diagram) {
        var strategies = [];
        var strategy;
        strategy = new core_1.LinearLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        diagram.LayoutSettings.LayoutStrategies.set("linear", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineHangerLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxSiblingsPerRow = 2;
        diagram.LayoutSettings.LayoutStrategies.set("hanger2", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineHangerLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxSiblingsPerRow = 4;
        diagram.LayoutSettings.LayoutStrategies.set("hanger4", strategy);
        strategies.push(strategy);
        strategy = new core_1.SingleColumnLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Right;
        diagram.LayoutSettings.LayoutStrategies.set("singleColumnRight", strategy);
        strategies.push(strategy);
        strategy = new core_1.SingleColumnLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Left;
        diagram.LayoutSettings.LayoutStrategies.set("singleColumnLeft", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineFishboneLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxGroups = 1;
        diagram.LayoutSettings.LayoutStrategies.set("fishbone1", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineFishboneLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxGroups = 2;
        diagram.LayoutSettings.LayoutStrategies.set("fishbone2", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineFishboneLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxGroups = 3;
        diagram.LayoutSettings.LayoutStrategies.set("fishbone3", strategy);
        strategies.push(strategy);
        strategy = new core_1.MultiLineFishboneLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        strategy.MaxGroups = 4;
        diagram.LayoutSettings.LayoutStrategies.set("fishbone4", strategy);
        strategies.push(strategy);
        strategy = new core_1.StackingLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.InvalidValue;
        strategy.Orientation =
            core_1.StackOrientation.SingleRowHorizontal;
        diagram.LayoutSettings.LayoutStrategies.set("hstack", strategy);
        strategies.push(strategy);
        strategy = new core_1.StackingLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.InvalidValue;
        strategy.Orientation =
            core_1.StackOrientation.SingleColumnVertical;
        diagram.LayoutSettings.LayoutStrategies.set("vstack", strategy);
        strategies.push(strategy);
        strategy = new core_1.StackingLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.InvalidValue;
        strategy.Orientation =
            core_1.StackOrientation.SingleColumnVertical;
        diagram.LayoutSettings.LayoutStrategies.set("vstackMiddle", strategy);
        strategies.push(strategy);
        strategy = new core_1.StackingLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.InvalidValue;
        strategy.Orientation =
            core_1.StackOrientation.SingleColumnVertical;
        diagram.LayoutSettings.LayoutStrategies.set("vstackTop", strategy);
        strategies.push(strategy);
        strategy = new core_1.FishboneAssistantsLayoutStrategy();
        strategy.ParentAlignment = core_1.BranchParentAlignment.Center;
        diagram.LayoutSettings.LayoutStrategies.set("assistants", strategy);
        strategies.push(strategy);
        diagram.LayoutSettings.DefaultLayoutStrategyId = "vstack";
        diagram.LayoutSettings.DefaultAssistantLayoutStrategyId = "assistants";
        return strategies;
    };
    OrgChart.getDataSource = function (props) {
        var root = props.root, childNodesGetter = props.childNodesGetter, keyGetter = props.keyGetter, isAssistantGetter = props.isAssistantGetter;
        var items = new Map();
        var sortedKeys = [];
        var processNode = function (node, parentKey) {
            var e_1, _a;
            if (parentKey === void 0) { parentKey = null; }
            var key = keyGetter(node);
            if (process.env.NODE_ENV !== "production") {
                if (!key) {
                    throw Error("Invalid key");
                }
                if (items.has(key)) {
                    throw Error("Duplicate key");
                }
            }
            sortedKeys.push(key);
            var emphasized = isAssistantGetter ? isAssistantGetter(node) : false;
            items.set(key, {
                IsAssistant: emphasized,
                Id: key,
                data: node,
                parentKey: parentKey,
            });
            try {
                for (var _b = __values(childNodesGetter(node)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    processNode(childNode, key);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        processNode(root, null);
        var getDataItem = function (id) {
            var item = items.get(id);
            if (item == null) {
                throw Error("Could not find item");
            }
            return item;
        };
        return {
            GetDataItemFunc: function (id) { return getDataItem(id); },
            GetParentKeyFunc: function (id) { var _a; return ((_a = items.get(id)) === null || _a === void 0 ? void 0 : _a.parentKey) || null; },
            AllDataItemIds: sortedKeys,
        };
    };
    OrgChart.getBranchOptimizerStackers = function (node) {
        if (node.IsAssistantRoot) {
            return null;
        }
        return node.Level === 0 // this is Node for boxContainer.SystemRoot, which is not visible itself
            ? "vstackTop"
            : node.Level === 1 // this is children of SystemRoot - they appear as roots in the diagram
                ? "vstackMiddle"
                : "hstack";
    };
    OrgChart.getBranchOptimizerSmart = function (node) {
        if (node.IsAssistantRoot) {
            return null;
        }
        var childCount = node.ChildCount;
        if (childCount <= 1) {
            return "vstack";
        }
        var nonLeafChildren = 0;
        for (var i = 0; i < childCount; i++) {
            if (node.Children[i].ChildCount > 0) {
                nonLeafChildren++;
            }
        }
        if (nonLeafChildren <= 1) {
            if (childCount <= 4) {
                return "vstack";
            }
            if (childCount <= 8) {
                return "fishbone1";
            }
            return "fishbone2";
        }
        return "hanger4";
    };
    OrgChart.prototype.componentWillUnmount = function () {
        this._mounted = true;
        clearTimeout(this._tid);
        cancelAnimationFrame(this._tid);
        // @ts-ignore
        if (typeof window.cancelIdleCallback === "function") {
            // @ts-ignore
            window.cancelIdleCallback(this._tid);
        }
    };
    OrgChart.getDerivedStateFromProps = function (props, state) {
        if (props !== state.prevProps) {
            var diagram = OrgChart.createDiagram(props);
            var placeholders = OrgChart.getPlaceholders(diagram, state.nodes);
            return __assign(__assign({ diagram: diagram }, placeholders), { prevProps: props, renderIndex: state.renderIndex + 1 });
        }
        return { prevProps: props };
    };
    OrgChart.prototype.componentWillMount = function () {
        var nextState = OrgChart.getDerivedStateFromProps(this.props, this.state);
        // @ts-ignore
        this.setState(nextState);
    };
    OrgChart.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps !== this.props) {
            var nextState = OrgChart.getDerivedStateFromProps(nextProps, this.state);
            // @ts-ignore
            this.setState(nextState);
        }
    };
    OrgChart.createDiagram = function (props) {
        var e_2, _a;
        var layout = props.layout, assistantLayout = props.assistantLayout, _b = props.parentSpacing, parentSpacing = _b === void 0 ? 40 : _b, _c = props.siblingSpacing, siblingSpacing = _c === void 0 ? 30 : _c, _d = props.connectorAlignment, connectorAlignment = _d === void 0 ? core_1.ConnectorAlignment.Edge : _d, _e = props.connectorThickness, connectorThickness = _e === void 0 ? 1 : _e;
        var dataSource = OrgChart.getDataSource(props);
        var boxContainer = new core_1.BoxContainer(dataSource);
        var diagram = new OrgChartDiagram(dataSource);
        diagram.Boxes = boxContainer;
        var strategies = OrgChart.assignStrategies(diagram);
        if (layout instanceof core_1.LayoutStrategyBase) {
            diagram.LayoutSettings.LayoutStrategies.set("custom", layout);
        }
        if (assistantLayout instanceof core_1.LayoutStrategyBase) {
            diagram.LayoutSettings.LayoutStrategies.set("assistantCustom", assistantLayout);
        }
        try {
            for (var strategies_1 = __values(strategies), strategies_1_1 = strategies_1.next(); !strategies_1_1.done; strategies_1_1 = strategies_1.next()) {
                var strategy = strategies_1_1.value;
                strategy.ChildConnectorHookLength = parentSpacing / 2;
                strategy.ParentChildSpacing = parentSpacing;
                strategy.SiblingSpacing = siblingSpacing;
                strategy.ConnectorAlignment = connectorAlignment;
                strategy.ConnectorThickness = connectorThickness;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (strategies_1_1 && !strategies_1_1.done && (_a = strategies_1.return)) _a.call(strategies_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return diagram;
    };
    OrgChart.getPlaceholders = function (diagram, prevNodes) {
        var e_3, _a, e_4, _b;
        var dataSource = diagram.DataSource;
        var nodes = [];
        var prevNodesByDataId = new Map();
        try {
            for (var prevNodes_1 = __values(prevNodes), prevNodes_1_1 = prevNodes_1.next(); !prevNodes_1_1.done; prevNodes_1_1 = prevNodes_1.next()) {
                var node = prevNodes_1_1.value;
                prevNodesByDataId.set(node.dataId, node);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (prevNodes_1_1 && !prevNodes_1_1.done && (_a = prevNodes_1.return)) _a.call(prevNodes_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var DEFAULT_RECT = {
            left: 0,
            top: 0,
            // unused
            width: "",
            height: "",
        };
        try {
            for (var _c = __values(diagram.Boxes.BoxesById.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var box = _d.value;
                if (!box.IsDataBound) {
                    continue;
                }
                var id = box.Id;
                var dataId = box.DataId || "";
                var data = dataSource.GetDataItemFunc(dataId).data;
                var prevNode = prevNodesByDataId.get(dataId);
                var nextRect = (prevNode === null || prevNode === void 0 ? void 0 : prevNode.rect) || DEFAULT_RECT;
                nodes.push({
                    rect: {
                        left: nextRect.left,
                        top: nextRect.top,
                        width: "auto",
                        height: "auto",
                    },
                    data: data,
                    dataId: box.DataId || String(id),
                    boxId: id,
                    assistant: box.IsAssistant,
                    drawStage: prevNode == null
                        ? DrawStage.MEASURE_HIDDEN
                        : DrawStage.MEASURE_VISIBLE,
                });
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_4) throw e_4.error; }
        }
        nodes.sort(function (a, b) { return a.boxId - b.boxId; });
        return { hidden: true, nodes: nodes };
    };
    OrgChart.prototype.drawDiagram = function (diagram, debug) {
        if (diagram !== this.state.diagram) {
            return;
        }
        if (diagram.DataSource.AllDataItemIds.length === 0) {
            return;
        }
        var state = new core_1.LayoutState(diagram);
        var nodeMap = new Map();
        var container = this._container;
        if (container) {
            container.querySelectorAll("[data-box-id]").forEach(function (node) {
                var id = node.getAttribute("data-box-id");
                if (id) {
                    nodeMap.set(parseInt(id), node);
                }
            });
        }
        // state.OperationChanged = this.onLayoutStateChanged;
        state.LayoutOptimizerFunc = this.onComputeBranchOptimizer;
        state.BoxSizeFunc = function (dataId) {
            if (dataId == null) {
                return NOOP_SIZE;
            }
            var box = diagram.Boxes.BoxesByDataId.get(dataId);
            if (box) {
                var element = nodeMap.get(box.Id);
                if (element) {
                    // force recalculate
                    void element.offsetWidth;
                    void element.offsetHeight;
                    var rect = element.getBoundingClientRect();
                    return new core_1.Size(rect.width || 1, rect.height || 1);
                }
            }
            return NOOP_SIZE;
        };
        core_1.LayoutAlgorithm.Apply(state);
        if (diagram.VisualTree == null) {
            throw Error("VisualTree is null");
        }
        var diagramBoundary = core_1.LayoutAlgorithm.ComputeBranchVisualBoundingRect(diagram.VisualTree);
        var offsetX = -diagramBoundary.Left;
        var offsetY = -diagramBoundary.Top;
        var nodes = [];
        var lines = [];
        var boundaries = [];
        diagram.VisualTree.IterateParentFirst(function (node) {
            if (node.State.IsHidden) {
                return false;
            }
            var box = node.Element;
            if (!box.IsDataBound) {
                return true;
            }
            // All boxes have already been rendered before the chart layout,
            // to have all box sizes available before layout.
            // So now we only have to position them.
            // Connectors, however, are not rendered until layout is complete (see next block).
            var x = node.State.TopLeft.X + offsetX;
            var y = node.State.TopLeft.Y + offsetY;
            var dataId = box.DataId || "";
            var data = diagram.DataSource.GetDataItemFunc(dataId).data;
            nodes.push({
                rect: {
                    left: x,
                    top: y,
                    width: box.Size.Width,
                    height: box.Size.Height,
                },
                data: data,
                dataId: dataId || String(box.Id),
                boxId: box.Id,
                assistant: box.IsAssistant,
                drawStage: DrawStage.RENDER,
            });
            if (debug) {
                boundaries.push({
                    branchLeft: node.State.BranchExterior.Left,
                    branchTop: node.State.BranchExterior.Top,
                    left: node.State.BranchExterior.Left + offsetX,
                    top: node.State.BranchExterior.Top + offsetY,
                    width: node.State.BranchExterior.Size.Width,
                    height: node.State.BranchExterior.Size.Height,
                });
            }
            // Render connectors
            if (node.State.Connector != null) {
                var segments = node.State.Connector.Segments;
                for (var ix = 0; ix < segments.length; ix++) {
                    var edge = segments[ix];
                    var direction = "horizontal";
                    var assistant = box.IsAssistant;
                    var topLeft = void 0;
                    var width_1 = 0;
                    var height_1 = 0;
                    if (edge.From.Y === edge.To.Y) {
                        direction = "horizontal";
                        height_1 = 1;
                        if (edge.From.X < edge.To.X) {
                            topLeft = edge.From;
                            width_1 = edge.To.X - edge.From.X;
                        }
                        else {
                            topLeft = edge.To;
                            width_1 = edge.From.X - edge.To.X;
                        }
                    }
                    else {
                        direction = "vertical";
                        if (edge.From.Y < edge.To.Y) {
                            topLeft = edge.From;
                            height_1 = edge.To.Y - edge.From.Y;
                        }
                        else {
                            topLeft = edge.To;
                            height_1 = edge.From.Y - edge.To.Y;
                        }
                    }
                    lines.push({
                        direction: direction,
                        assistant: assistant,
                        data: data,
                        dataId: dataId,
                        boxId: box.Id,
                        index: ix,
                        rect: {
                            left: topLeft.X + offsetX,
                            top: topLeft.Y + offsetY,
                            width: width_1,
                            height: height_1,
                        },
                    });
                }
            }
            return true;
        });
        var onRenderComplete = this.props.onRenderComplete;
        var width = diagramBoundary.Size.Width;
        var height = diagramBoundary.Size.Height;
        this.setState({
            width: width,
            height: height,
            lines: lines,
            nodes: nodes,
            boundaries: boundaries,
            drawStage: DrawStage.RENDER,
        }, function () {
            if (onRenderComplete) {
                onRenderComplete(width, height);
            }
        });
    };
    OrgChart.prototype.render = function () {
        var _this = this;
        var _a = this.state, lines = _a.lines, containerWidth = _a.width, containerHeight = _a.height, nodes = _a.nodes, drawStage = _a.drawStage, boundaries = _a.boundaries;
        var _b = this.props, lineVerticalClassName = _b.lineVerticalClassName, lineHorizontalClassName = _b.lineHorizontalClassName, lineHorizontalStyle = _b.lineHorizontalStyle, lineVerticalStyle = _b.lineVerticalStyle, containerStyle = _b.containerStyle, renderNode = _b.renderNode, renderNodeContainer = _b.renderNodeContainer, renderNodeLine = _b.renderNodeLine, nodeContainerStyle = _b.nodeContainerStyle, isValidNode = _b.isValidNode, measureStrategy = _b.measureStrategy;
        var lineClassNames = {
            vertical: lineVerticalClassName,
            horizontal: lineHorizontalClassName,
        };
        var lineStyles = {
            vertical: lineVerticalStyle,
            horizontal: lineHorizontalStyle,
        };
        var handleEffect = measureStrategy === "effect" ? function () { return _this.safelyDrawDiagram(); } : null;
        return (react_1.default.createElement("div", { style: __assign({ width: containerWidth, height: containerHeight, position: "relative" }, containerStyle), ref: function (ref) { return (_this._container = ref); } },
            react_1.default.createElement("div", null, lines.map(function (_a, i) {
                var _b = _a.rect, width = _b.width, height = _b.height, left = _b.left, top = _b.top, data = _a.data, assistant = _a.assistant, direction = _a.direction, dataId = _a.dataId, index = _a.index;
                var isValid = isValidNode(dataId);
                if (!isValid) {
                    return null;
                }
                var props = {
                    "data-line-assistant": assistant,
                    "data-line-direction": direction,
                    className: lineClassNames[direction],
                    key: dataId + "-" + index,
                    style: __assign({ left: 0, top: 0, width: width,
                        height: height, transform: "translate3d(" + left + "px, " + top + "px, 0)", position: "absolute" }, lineStyles[direction]),
                };
                if (typeof renderNodeLine === "function") {
                    return renderNodeLine(data, props, {
                        drawStage: drawStage,
                        direction: direction,
                    });
                }
                var visible = drawStage === DrawStage.RENDER ||
                    drawStage === DrawStage.MEASURE_VISIBLE;
                // props.style = { ...props.style };
                props.style.visibility = visible ? "visible" : "hidden";
                props.style.pointerEvents = visible ? "auto" : "none";
                return react_1.default.createElement("div", __assign({}, props));
            })),
            react_1.default.createElement("div", null, nodes.map(function (context) {
                var _a = context.rect, top = _a.top, left = _a.left, width = _a.width, height = _a.height, dataId = context.dataId, dataBoxId = context.boxId, data = context.data, drawStage = context.drawStage;
                var isValid = isValidNode(dataId);
                if (!isValid) {
                    return null;
                }
                var children = renderNode(data);
                if (typeof handleEffect === "function" &&
                    drawStage !== DrawStage.RENDER) {
                    children = react_1.default.createElement(Effect, { onEffect: handleEffect }, children);
                    handleEffect = null;
                }
                var props = {
                    "data-box-id": String(dataBoxId),
                    children: children,
                    key: dataId,
                    style: __assign({ left: 0, top: 0, transform: "translate3d(" + left + "px, " + top + "px, 0)", position: "absolute" }, nodeContainerStyle),
                };
                if (typeof renderNodeContainer === "function") {
                    return renderNodeContainer(data, props, { drawStage: drawStage });
                }
                var visible = drawStage === DrawStage.RENDER ||
                    drawStage === DrawStage.MEASURE_VISIBLE;
                // props.style = { ...props.style };
                props.style.visibility = visible ? "visible" : "hidden";
                props.style.pointerEvents = visible ? "auto" : "none";
                return react_1.default.createElement("div", __assign({}, props));
            })),
            react_1.default.createElement("div", null, boundaries.map(function (_a, i) {
                var top = _a.top, left = _a.left, width = _a.width, height = _a.height, branchLeft = _a.branchLeft, branchTop = _a.branchTop;
                return (react_1.default.createElement("div", { key: i, style: {
                        transform: "translate3d(" + left + "px, " + top + "px, 0)",
                        width: width,
                        height: height,
                        position: "absolute",
                        top: 0,
                        left: 0,
                        zIndex: 0,
                        pointerEvents: "none",
                        visibility: drawStage === DrawStage.RENDER ? "visible" : "hidden",
                        background: "rgba(255,0,0,0.1)",
                        border: "1px solid red",
                    } },
                    react_1.default.createElement("div", { style: {
                            backgroundColor: "red",
                            color: "white",
                            display: "inline-block",
                            padding: "0 2px",
                        } },
                        "(",
                        +branchLeft.toFixed(2),
                        ",",
                        +branchTop.toFixed(2),
                        ")",
                        " ",
                        +width.toFixed(2),
                        "x",
                        +height.toFixed(2))));
            }))));
    };
    return OrgChart;
}(react_1.default.Component));
exports.default = OrgChart;
