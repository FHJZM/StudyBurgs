"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var LinearLayoutStrategy_1 = __importDefault(require("./LinearLayoutStrategy"));
var Box_1 = __importDefault(require("./Box"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var Edge_1 = __importDefault(require("./Edge"));
var Point_1 = __importDefault(require("./Point"));
var Connector_1 = __importDefault(require("./Connector"));
var Rect_1 = __importDefault(require("./Rect"));
var ConnectorAlignment_1 = __importDefault(require("./ConnectorAlignment"));
/// <summary>
/// Arranges child boxes in multiple lines under the parent.
/// Can only be configured to position parent in the middle of children.
/// Children are attached to long horizontal carriers,
/// with a central vertical carrier going through them from parent's bottom.
/// </summary>
var MultiLineHangerLayoutStrategy = /** @class */ (function (_super) {
    __extends(MultiLineHangerLayoutStrategy, _super);
    function MultiLineHangerLayoutStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /// <summary>
        /// Maximum number of siblings in a horizontal row.
        /// </summary>
        _this.MaxSiblingsPerRow = 4;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return true; };
        return _this;
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// </summary>
    MultiLineHangerLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        if (this.MaxSiblingsPerRow <= 0 || this.MaxSiblingsPerRow % 2 != 0) {
            throw new Error("MaxSiblingsPerRow must be a positive even value");
        }
        if (node.ChildCount <= this.MaxSiblingsPerRow) {
            // fall back to linear layout, only have one row of boxes
            _super.prototype.PreProcessThisNode.call(this, state, node);
            return;
        }
        node.State.NumberOfSiblings = node.ChildCount;
        // only add spacers for non-collapsed boxes
        if (node.State.NumberOfSiblings > 0) {
            var lastRowBoxCount = node.ChildCount % this.MaxSiblingsPerRow;
            // add one (for vertical spacer) into the count of layout columns
            node.State.NumberOfSiblingColumns = 1 + this.MaxSiblingsPerRow;
            node.State.NumberOfSiblingRows = Math.floor(node.ChildCount / this.MaxSiblingsPerRow);
            if (lastRowBoxCount != 0) {
                node.State.NumberOfSiblingRows++;
            }
            // include vertical spacers into the count of layout siblings
            node.State.NumberOfSiblings =
                node.ChildCount + node.State.NumberOfSiblingRows;
            if (lastRowBoxCount > 0 &&
                lastRowBoxCount <= Math.floor(this.MaxSiblingsPerRow / 2)) {
                // don't need the last spacer, last row is half-full or even less
                node.State.NumberOfSiblings--;
            }
            // sibling middle-spacers have to be inserted between siblings
            var ix = Math.floor(this.MaxSiblingsPerRow / 2);
            while (ix < node.State.NumberOfSiblings) {
                var siblingSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.InsertRegularChildBoxByIndex(ix, siblingSpacer);
                ix += node.State.NumberOfSiblingColumns;
            }
            // add parent vertical spacer to the end
            var verticalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
            node.AddRegularChildBox(verticalSpacer);
            // add horizontal spacers to the end
            for (var i = 0; i < node.State.NumberOfSiblingRows; i++) {
                var horizontalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.AddRegularChildBox(horizontalSpacer);
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    MultiLineHangerLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {
            // fall back to linear layout, only have one row of boxes
            _super.prototype.ApplyVerticalLayout.call(this, state, level);
            return;
        }
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.AssistantsRoot != null) {
            // assistants root has to be initialized with main node's exterior
            LayoutAlgorithm_1.default.CopyExteriorFrom(node.AssistantsRoot.State, node.State);
            LayoutAlgorithm_1.default.VerticalLayout(state, node.AssistantsRoot);
        }
        var prevRowExterior = new Dimensions_1.default(node.State.SiblingsRowV.From, node.AssistantsRoot == null
            ? node.State.SiblingsRowV.To
            : node.State.BranchExterior.Bottom);
        for (var row = 0; row < node.State.NumberOfSiblingRows; row++) {
            var siblingsRowExterior = Dimensions_1.default.MinMax();
            var spacing = row == 0 ? this.ParentChildSpacing : this.SiblingSpacing;
            // first, compute
            var from = row * node.State.NumberOfSiblingColumns;
            var to = Math.min(from + node.State.NumberOfSiblingColumns, node.State.NumberOfSiblings);
            for (var i = from; i < to; i++) {
                var child = node.Children[i];
                if (child.Element.IsSpecial) {
                    // skip vertical spacers for now
                    continue;
                }
                var rect = child.State;
                var top_1 = prevRowExterior.To + spacing;
                LayoutAlgorithm_1.default.MoveTo(child.State, rect.Left, top_1);
                child.State.BranchExterior = Rect_1.default.from(child.State.Size, child.State.TopLeft);
                siblingsRowExterior = Dimensions_1.default.add(siblingsRowExterior, new Dimensions_1.default(top_1, top_1 + rect.Size.Height));
            }
            siblingsRowExterior = new Dimensions_1.default(siblingsRowExterior.From, siblingsRowExterior.To);
            var siblingsBottom = Number.MIN_VALUE;
            for (var i = from; i < to; i++) {
                var child = node.Children[i];
                child.State.SiblingsRowV = siblingsRowExterior;
                // re-enter layout algorithm for child branch
                LayoutAlgorithm_1.default.VerticalLayout(state, child);
                siblingsBottom = Math.max(siblingsBottom, child.State.BranchExterior.Bottom);
            }
            prevRowExterior = new Dimensions_1.default(siblingsRowExterior.From, Math.max(siblingsBottom, siblingsRowExterior.To));
            // now assign size to the vertical spacer, if any
            var spacerIndex = from + Math.floor(node.State.NumberOfSiblingColumns / 2);
            if (spacerIndex < node.State.NumberOfSiblings) {
                // in the last row, spacer should only extend to the siblings row bottom,
                // because main vertical carrier does not go below last row
                // and thus cannot conflict with branches of children of the last row
                var spacerBottom = row == node.State.NumberOfSiblingRows - 1
                    ? node.Children[spacerIndex - 1].State.SiblingsRowV.To
                    : prevRowExterior.To;
                var spacer = node.Children[spacerIndex].State;
                LayoutAlgorithm_1.default.AdjustSpacer(spacer, 0, prevRowExterior.From, this.ParentConnectorShield, spacerBottom - prevRowExterior.From);
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    MultiLineHangerLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {
            // fall back to linear layout, only have one row of boxes
            _super.prototype.ApplyHorizontalLayout.call(this, state, level);
            return;
        }
        if (node.AssistantsRoot != null) {
            LayoutAlgorithm_1.default.HorizontalLayout(state, node.AssistantsRoot);
        }
        for (var col = 0; col < node.State.NumberOfSiblingColumns; col++) {
            // first, perform horizontal layout for every node in this column
            for (var row = 0; row < node.State.NumberOfSiblingRows; row++) {
                var ix = row * node.State.NumberOfSiblingColumns + col;
                if (ix >= node.State.NumberOfSiblings) {
                    break;
                }
                var child = node.Children[ix];
                // re-enter layout algorithm for child branch
                LayoutAlgorithm_1.default.HorizontalLayout(state, child);
            }
            LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateColumn(node, col));
        }
        // now align children under parent
        var rect = node.State;
        var spacer = node.Children[Math.floor(node.State.NumberOfSiblingColumns / 2)];
        var desiredCenter = spacer.State.CenterH;
        var diff = rect.CenterH - desiredCenter;
        LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
        // vertical connector from parent
        var verticalSpacer = node.Children[node.State.NumberOfSiblings];
        LayoutAlgorithm_1.default.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);
        state.MergeSpacer(verticalSpacer);
        // horizontal row carrier protectors
        var spacing = this.ParentChildSpacing;
        for (var firstInRowIndex = 0; firstInRowIndex < node.State.NumberOfSiblings; firstInRowIndex += node.State.NumberOfSiblingColumns) {
            var firstInRow = node.Children[firstInRowIndex].State;
            var lastInRow = node.Children[Math.min(firstInRowIndex + node.State.NumberOfSiblingColumns - 1, node.State.NumberOfSiblings - 1)].State;
            var horizontalSpacer = node.Children[1 +
                node.State.NumberOfSiblings +
                Math.floor(firstInRowIndex / node.State.NumberOfSiblingColumns)];
            var width = lastInRow.Right >= verticalSpacer.State.Right
                ? lastInRow.Right - firstInRow.Left
                : // extend protector at least to the central carrier
                    verticalSpacer.State.Right - firstInRow.Left;
            LayoutAlgorithm_1.default.AdjustSpacer(horizontalSpacer.State, firstInRow.Left, firstInRow.SiblingsRowV.From - spacing, width, spacing);
            state.MergeSpacer(horizontalSpacer);
            spacing = this.SiblingSpacing;
        }
    };
    MultiLineHangerLayoutStrategy.prototype.EnumerateColumn = function (branchRoot, col) {
        var nodes = [];
        for (var row = 0; row < branchRoot.State.NumberOfSiblingRows; row++) {
            var ix = row * branchRoot.State.NumberOfSiblingColumns + col;
            if (ix >= branchRoot.State.NumberOfSiblings) {
                break;
            }
            nodes.push(branchRoot.Children[ix]);
        }
        return nodes;
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    MultiLineHangerLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        var e_1, _a;
        if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {
            // fall back to linear layout, only have one row of boxes
            _super.prototype.RouteConnectors.call(this, state, node);
            return;
        }
        // one parent connector (also serves as mid-sibling carrier) and horizontal carriers
        var count = 1 + node.State.NumberOfSiblingRows;
        try {
            for (var _b = __values(node.Children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                // normal boxes get one upward hook
                if (!child.Element.IsSpecial) {
                    count++;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var segments = [];
        var rootRect = node.State;
        var center = rootRect.CenterH;
        var rootRectV = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
            ? rootRect.CenterV
            : rootRect.Bottom;
        var verticalCarrierHeight = node.Children[node.State.NumberOfSiblings - 1].State.SiblingsRowV.From -
            this.ChildConnectorHookLength -
            rootRectV;
        // central mid-sibling vertical connector, from parent to last row
        segments[0] = new Edge_1.default(new Point_1.default(center, rootRectV), new Point_1.default(center, rootRectV + verticalCarrierHeight));
        // short hook for each child
        var ix = 1;
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var child = node.Children[i];
            if (!child.Element.IsSpecial) {
                var childRect = child.State;
                var childCenter = childRect.CenterH;
                var childRectV = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                    ? childRect.CenterV
                    : childRect.Top;
                segments[ix++] = new Edge_1.default(new Point_1.default(childCenter, childRectV), new Point_1.default(childCenter, childRectV - this.ChildConnectorHookLength));
            }
        }
        // horizontal carriers go from leftmost child hook to righmost child hook
        // for the last row which is just half or less full, it will only go to the central vertical carrier
        var lastChildHookIndex = count - node.State.NumberOfSiblingRows - 1;
        for (var firstInRowIndex = 1; firstInRowIndex < count - node.State.NumberOfSiblingRows; firstInRowIndex += this.MaxSiblingsPerRow) {
            var firstInRow = segments[firstInRowIndex];
            var lastInRow = segments[Math.min(firstInRowIndex + this.MaxSiblingsPerRow - 1, lastChildHookIndex)];
            if (lastInRow.From.X < segments[0].From.X) {
                segments[ix++] = new Edge_1.default(new Point_1.default(firstInRow.To.X, firstInRow.To.Y), new Point_1.default(segments[0].To.X, firstInRow.To.Y));
            }
            else {
                segments[ix++] = new Edge_1.default(new Point_1.default(firstInRow.To.X, firstInRow.To.Y), new Point_1.default(lastInRow.To.X, firstInRow.To.Y));
            }
        }
        node.State.Connector = new Connector_1.default(segments);
    };
    return MultiLineHangerLayoutStrategy;
}(LinearLayoutStrategy_1.default));
exports.default = MultiLineHangerLayoutStrategy;
