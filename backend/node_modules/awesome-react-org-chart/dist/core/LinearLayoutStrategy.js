"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Point_1 = __importDefault(require("./Point"));
var LayoutStrategyBase_1 = __importDefault(require("./LayoutStrategyBase"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var Box_1 = __importDefault(require("./Box"));
var BranchParentAlignment_1 = __importDefault(require("./BranchParentAlignment"));
var Rect_1 = __importDefault(require("./Rect"));
var Edge_1 = __importDefault(require("./Edge"));
var Connector_1 = __importDefault(require("./Connector"));
var ConnectorAlignment_1 = __importDefault(require("./ConnectorAlignment"));
var LinearLayoutStrategy = /** @class */ (function (_super) {
    __extends(LinearLayoutStrategy, _super);
    function LinearLayoutStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return true; };
        return _this;
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// </summary>
    LinearLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        if (node.ChildCount > 0) {
            node.State.NumberOfSiblings = node.Element.IsCollapsed
                ? 0
                : node.ChildCount;
            // only add spacers for non-collapsed boxes
            if (!node.Element.IsCollapsed) {
                var verticalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.AddRegularChildBox(verticalSpacer);
                var horizontalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.AddRegularChildBox(horizontalSpacer);
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    LinearLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.AssistantsRoot != null) {
            // assistants root has to be initialized with main node's exterior
            LayoutAlgorithm_1.default.CopyExteriorFrom(node.AssistantsRoot.State, node.State);
            LayoutAlgorithm_1.default.VerticalLayout(state, node.AssistantsRoot);
        }
        if (node.State.NumberOfSiblings == 0) {
            return;
        }
        var siblingsRowExterior = Dimensions_1.default.MinMax();
        var top;
        if (node.AssistantsRoot == null) {
            if (node.State.SiblingsRowV == null) {
                throw Error("SiblingsRowV is null");
            }
            top = node.State.SiblingsRowV.To + this.ParentChildSpacing;
        }
        else {
            top = node.State.BranchExterior.Bottom + this.ParentChildSpacing;
        }
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var child = node.Children[i];
            var rect = child.State;
            LayoutAlgorithm_1.default.MoveTo(child.State, 0, top);
            if (child.State.Size == null) {
                throw Error("Size is null");
            }
            child.State.BranchExterior = Rect_1.default.from(child.State.Size, child.State.TopLeft);
            if (rect.Size == null) {
                throw Error("Size is null");
            }
            siblingsRowExterior = Dimensions_1.default.add(siblingsRowExterior, new Dimensions_1.default(top, top + rect.Size.Height));
        }
        siblingsRowExterior = new Dimensions_1.default(siblingsRowExterior.From, siblingsRowExterior.To);
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var child = node.Children[i];
            child.State.SiblingsRowV = siblingsRowExterior;
            // re-enter layout algorithm for child branch
            LayoutAlgorithm_1.default.VerticalLayout(state, child);
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    LinearLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.AssistantsRoot != null) {
            LayoutAlgorithm_1.default.HorizontalLayout(state, node.AssistantsRoot);
        }
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var child = node.Children[i];
            // re-enter layout algorithm for child branch
            LayoutAlgorithm_1.default.HorizontalLayout(state, child);
        }
        if (node.Level > 0 && node.ChildCount > 0) {
            var rect = node.State;
            var leftmost = node.Children[0].State.CenterH;
            var rightmost = node.Children[node.State.NumberOfSiblings - 1].State.CenterH;
            var desiredCenter = node.State.NumberOfSiblings == 1 ||
                this.ParentAlignment == BranchParentAlignment_1.default.Center
                ? leftmost + (rightmost - leftmost) / 2
                : this.ParentAlignment == BranchParentAlignment_1.default.Left
                    ? leftmost + this.ChildConnectorHookLength
                    : rightmost - this.ChildConnectorHookLength;
            var center = rect.CenterH;
            var diff = center - desiredCenter;
            LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
            // vertical connector from parent
            var verticalSpacer = node.Children[node.State.NumberOfSiblings];
            if (node.Children[0].State.SiblingsRowV == null) {
                throw Error("SiblingsRowV is null");
            }
            LayoutAlgorithm_1.default.AdjustSpacer(verticalSpacer.State, center - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);
            state.MergeSpacer(verticalSpacer);
            // horizontal protector
            var firstInRow = node.Children[0].State;
            var horizontalSpacer = node.Children[node.State.NumberOfSiblings + 1];
            if (firstInRow.SiblingsRowV == null) {
                throw Error("SiblingsRowV is null");
            }
            LayoutAlgorithm_1.default.AdjustSpacer(horizontalSpacer.State, firstInRow.Left, firstInRow.SiblingsRowV.From - this.ParentChildSpacing, node.Children[node.State.NumberOfSiblings - 1].State.Right -
                firstInRow.Left, this.ParentChildSpacing);
            state.MergeSpacer(horizontalSpacer);
        }
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    LinearLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        var normalChildCount = node.State.NumberOfSiblings;
        var count = normalChildCount == 0
            ? 0 // no visible children = no edges
            : normalChildCount == 1
                ? 1 // one child = one direct edge between parent and child
                : 1 + // one downward edge for parent
                    1 + // one for horizontal carrier
                    normalChildCount; // one upward edge for each child
        if (count == 0) {
            node.State.Connector = null;
            return;
        }
        var segments = [];
        var rootRect = node.State;
        var center = rootRect.CenterH;
        if (node.Children == null) {
            throw new Error("State is present, but children not set");
        }
        if (count == 1) {
            segments[0] = new Edge_1.default(new Point_1.default(center, this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? rootRect.CenterV
                : rootRect.Bottom), new Point_1.default(center, this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? node.Children[0].State.CenterV
                : node.Children[0].State.Top));
        }
        else {
            if (node.Children[0].State.SiblingsRowV == null) {
                throw Error("SiblingsRowV is null");
            }
            var rootRectV = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? rootRect.CenterV
                : rootRect.Bottom;
            var space = node.Children[0].State.SiblingsRowV.From - rootRectV;
            segments[0] = new Edge_1.default(new Point_1.default(center, rootRectV), new Point_1.default(center, rootRectV + space - this.ChildConnectorHookLength));
            for (var i = 0; i < normalChildCount; i++) {
                var childRect = node.Children[i].State;
                var childCenter = childRect.CenterH;
                segments[1 + i] = new Edge_1.default(new Point_1.default(childCenter, childRect.Top), new Point_1.default(childCenter, childRect.Top - this.ChildConnectorHookLength));
            }
            segments[count - 1] = new Edge_1.default(new Point_1.default(segments[1].To.X, segments[1].To.Y), new Point_1.default(segments[count - 2].To.X, segments[1].To.Y));
        }
        node.State.Connector = new Connector_1.default(segments);
    };
    return LinearLayoutStrategy;
}(LayoutStrategyBase_1.default));
exports.default = LinearLayoutStrategy;
