"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var LayoutStrategyBase_1 = __importDefault(require("./LayoutStrategyBase"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var BranchParentAlignment_1 = __importDefault(require("./BranchParentAlignment"));
var Size_1 = __importDefault(require("./Size"));
var Rect_1 = __importDefault(require("./Rect"));
var StackOrientation_1 = __importDefault(require("./StackOrientation"));
var StackingLayoutStrategy = /** @class */ (function (_super) {
    __extends(StackingLayoutStrategy, _super);
    /// <summary>
    /// Ctr.
    /// </summary>
    function StackingLayoutStrategy() {
        var _this = _super.call(this) || this;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return false; };
        _this.Orientation = StackOrientation_1.default.SingleRowHorizontal;
        _this.ParentAlignment = BranchParentAlignment_1.default.InvalidValue;
        _this.ChildConnectorHookLength = 0;
        _this.ParentConnectorShield = 0;
        _this.SiblingSpacing = 5;
        return _this;
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// This strategy does not use connectors and spacers.
    /// </summary>
    StackingLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        node.State.NumberOfSiblings = node.Element.IsCollapsed
            ? 0
            : node.ChildCount;
        if (node.State.NumberOfSiblings > 0) {
            // this strategy requires certain adjustments to be made to the box sizes
            // they will only affect corresponding Nodes, not the size on the box itself
            if (this.Orientation != StackOrientation_1.default.SingleRowHorizontal &&
                this.Orientation != StackOrientation_1.default.SingleColumnVertical) {
                throw new Error("InvalidOperationException: Unsupported value for orientation: " +
                    this.Orientation);
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    StackingLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.State.NumberOfSiblings == 0) {
            return;
        }
        var siblingsRowExterior = Dimensions_1.default.MinMax();
        if (this.Orientation == StackOrientation_1.default.SingleRowHorizontal) {
            var top_1 = node.AssistantsRoot == null
                ? node.State.SiblingsRowV.To + this.ParentChildSpacing
                : node.State.BranchExterior.Bottom + this.ParentChildSpacing;
            for (var i = 0; i < node.State.NumberOfSiblings; i++) {
                var child = node.Children[i];
                var rect = child.State;
                LayoutAlgorithm_1.default.MoveTo(child.State, 0, top_1);
                child.State.BranchExterior = Rect_1.default.from(child.State.Size, child.State.TopLeft);
                siblingsRowExterior = Dimensions_1.default.add(siblingsRowExterior, new Dimensions_1.default(top_1, top_1 + rect.Size.Height));
            }
            siblingsRowExterior = new Dimensions_1.default(siblingsRowExterior.From, siblingsRowExterior.To);
            for (var i = 0; i < node.State.NumberOfSiblings; i++) {
                var child = node.Children[i];
                child.State.SiblingsRowV = siblingsRowExterior;
                // re-enter layout algorithm for child branch
                LayoutAlgorithm_1.default.VerticalLayout(state, child);
            }
        }
        else if (this.Orientation == StackOrientation_1.default.SingleColumnVertical) {
            var prevRowExterior = new Dimensions_1.default(node.State.SiblingsRowV.From, node.State.SiblingsRowV.To);
            for (var row = 0; row < node.State.NumberOfSiblings; row++) {
                // first, compute
                var child = node.Children[row];
                var rect = child.State;
                var top_2 = prevRowExterior.To +
                    (row == 0 ? this.ParentChildSpacing : this.SiblingSpacing);
                LayoutAlgorithm_1.default.MoveTo(child.State, rect.Left, top_2);
                child.State.BranchExterior = Rect_1.default.from(child.State.Size, child.State.TopLeft);
                var rowExterior = new Dimensions_1.default(top_2, top_2 + rect.Size.Height);
                child = node.Children[row];
                child.State.SiblingsRowV = rowExterior;
                // re-enter layout algorithm for child branch
                LayoutAlgorithm_1.default.VerticalLayout(state, child);
                var childBranchBottom = child.State.BranchExterior.Bottom;
                prevRowExterior = new Dimensions_1.default(rowExterior.From, Math.max(childBranchBottom, rowExterior.To));
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    StackingLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var e_1, _a;
        var node = level.BranchRoot;
        try {
            for (var _b = __values(node.Children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                // re-enter layout algorithm for child branch
                LayoutAlgorithm_1.default.HorizontalLayout(state, child);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (node.ChildCount > 0) {
            if (this.Orientation == StackOrientation_1.default.SingleRowHorizontal) {
                // now auto-extend or contract the parent box
                var width = node.Children[node.State.NumberOfSiblings - 1].State.Right -
                    node.Children[0].State.Left;
                node.State.Size = new Size_1.default(Math.max(node.State.Size.Width, width), node.State.Size.Height);
                // now position children under the parent
                var center = (node.Children[0].State.Left +
                    node.Children[node.ChildCount - 1].State.Right) /
                    2;
                var desiredCenter = node.State.CenterH;
                var diff = desiredCenter - center;
                LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
            }
            else if (this.Orientation == StackOrientation_1.default.SingleColumnVertical) {
                LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, node.Children);
                // now position children under the parent
                var center = node.Children[0].State.CenterH;
                var desiredCenter = node.State.CenterH;
                var diff = desiredCenter - center;
                LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
            }
        }
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    StackingLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        // this strategy does not use connectors
    };
    return StackingLayoutStrategy;
}(LayoutStrategyBase_1.default));
exports.default = StackingLayoutStrategy;
