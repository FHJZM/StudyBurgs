"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var LayoutStrategyBase_1 = __importDefault(require("./LayoutStrategyBase"));
var Box_1 = __importDefault(require("./Box"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var BranchParentAlignment_1 = __importDefault(require("./BranchParentAlignment"));
var Edge_1 = __importDefault(require("./Edge"));
var Point_1 = __importDefault(require("./Point"));
var Connector_1 = __importDefault(require("./Connector"));
var Rect_1 = __importDefault(require("./Rect"));
var ConnectorAlignment_1 = __importDefault(require("./ConnectorAlignment"));
var SingleColumnLayoutStrategy = /** @class */ (function (_super) {
    __extends(SingleColumnLayoutStrategy, _super);
    function SingleColumnLayoutStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return true; };
        return _this;
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// </summary>
    SingleColumnLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        if (this.ParentAlignment != BranchParentAlignment_1.default.Left &&
            this.ParentAlignment != BranchParentAlignment_1.default.Right) {
            throw new Error("InvalidOperationException: Unsupported value for ParentAlignment");
        }
        node.State.NumberOfSiblings = node.Element.IsCollapsed
            ? 0
            : node.ChildCount;
        // only add spacers for non-collapsed boxes
        if (node.State.NumberOfSiblings > 0 && node.Level > 0) {
            // add one (for vertical spacer) into the count of layout columns
            node.State.NumberOfSiblingColumns = 1;
            node.State.NumberOfSiblingRows = node.ChildCount;
            // add parent's vertical carrier to the end
            var verticalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
            node.AddRegularChildBox(verticalSpacer);
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    SingleColumnLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.AssistantsRoot != null) {
            // assistants root has to be initialized with main node's exterior
            LayoutAlgorithm_1.default.CopyExteriorFrom(node.AssistantsRoot.State, node.State);
            LayoutAlgorithm_1.default.VerticalLayout(state, node.AssistantsRoot);
        }
        var prevRowExterior = new Dimensions_1.default(node.State.SiblingsRowV.From, node.AssistantsRoot == null
            ? node.State.SiblingsRowV.To
            : node.State.BranchExterior.Bottom);
        for (var row = 0; row < node.State.NumberOfSiblings; row++) {
            // first, compute
            var child = node.Children[row];
            var rect = child.State;
            var top_1 = prevRowExterior.To +
                (row == 0 ? this.ParentChildSpacing : this.SiblingSpacing);
            LayoutAlgorithm_1.default.MoveTo(child.State, rect.Left, top_1);
            child.State.BranchExterior = Rect_1.default.from(child.State.Size, child.State.TopLeft);
            var rowExterior = new Dimensions_1.default(top_1, top_1 + rect.Size.Height);
            child = node.Children[row];
            child.State.SiblingsRowV = rowExterior;
            // re-enter layout algorithm for child branch
            LayoutAlgorithm_1.default.VerticalLayout(state, child);
            var childBranchBottom = child.State.BranchExterior.Bottom;
            prevRowExterior = new Dimensions_1.default(rowExterior.From, Math.max(childBranchBottom, rowExterior.To));
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    SingleColumnLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var node = level.BranchRoot;
        var nodeState = node.State;
        if (node.AssistantsRoot != null) {
            LayoutAlgorithm_1.default.HorizontalLayout(state, node.AssistantsRoot);
        }
        // first, perform horizontal layout for every node in this column
        for (var row = 0; row < nodeState.NumberOfSiblings; row++) {
            var child = node.Children[row];
            // re-enter layout algorithm for child branch
            // siblings are guaranteed not to offend each other
            LayoutAlgorithm_1.default.HorizontalLayout(state, child);
        }
        // now align the column
        var edges = LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateColumn(node));
        if (node.Level > 0 && node.ChildCount > 0) {
            var rect = node.State;
            var diff = void 0;
            if (this.ParentAlignment == BranchParentAlignment_1.default.Left) {
                var desiredLeft = rect.CenterH + this.ParentConnectorShield / 2;
                diff = desiredLeft - edges.From;
            }
            else if (this.ParentAlignment == BranchParentAlignment_1.default.Right) {
                var desiredRight = rect.CenterH - this.ParentConnectorShield / 2;
                diff = desiredRight - edges.To;
            }
            else {
                throw new Error("InvalidOperationException: Invalid ParentAlignment setting");
            }
            // vertical connector from parent
            LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
            // spacer for the vertical carrier
            var verticalSpacer = node.Level > 0 ? node.Children[node.ChildCount - 1] : null;
            if (verticalSpacer != null) {
                var spacerTop = node.State.Bottom;
                var spacerBottom = node.Children[node.ChildCount - 2].State.Bottom;
                LayoutAlgorithm_1.default.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, spacerTop, this.ParentConnectorShield, spacerBottom - spacerTop);
                state.MergeSpacer(verticalSpacer);
            }
        }
    };
    SingleColumnLayoutStrategy.prototype.EnumerateColumn = function (branchRoot) {
        var nodes = [];
        for (var i = 0; i < branchRoot.State.NumberOfSiblings; i++) {
            nodes.push(branchRoot.Children[i]);
        }
        return nodes;
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    SingleColumnLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        if (node.ChildCount == 0) {
            return;
        }
        // one parent connector (also serves as mid-sibling carrier) and horizontal carriers
        var count = 1 + node.State.NumberOfSiblings;
        var segments = Array(count);
        var rootRect = node.State;
        var center = rootRect.CenterH;
        var rootRectV = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
            ? rootRect.CenterV
            : rootRect.Bottom;
        var verticalCarrierHeight = node.Children[node.State.NumberOfSiblings - 1].State.CenterV -
            (this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? node.State.CenterV
                : node.State.Bottom);
        // big vertical connector, from parent to last row
        segments[0] = new Edge_1.default(new Point_1.default(center, rootRectV), new Point_1.default(center, rootRectV + verticalCarrierHeight));
        for (var ix = 0; ix < node.State.NumberOfSiblings; ix++) {
            var rect = node.Children[ix].State;
            var destination = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? rect.CenterH
                : this.ParentAlignment == BranchParentAlignment_1.default.Left
                    ? rect.Left
                    : rect.Right;
            segments[1 + ix] = new Edge_1.default(new Point_1.default(center, rect.CenterV), new Point_1.default(destination, rect.CenterV));
        }
        node.State.Connector = new Connector_1.default(segments);
    };
    return SingleColumnLayoutStrategy;
}(LayoutStrategyBase_1.default));
exports.default = SingleColumnLayoutStrategy;
