"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Rect_1 = __importDefault(require("./Rect"));
var BoxTree_1 = __importDefault(require("./BoxTree"));
var Operation_1 = __importDefault(require("./Operation"));
var Point_1 = __importDefault(require("./Point"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var Size_1 = __importDefault(require("./Size"));
var Utils_1 = require("./Utils");
var LayoutAlgorithm = /** @class */ (function () {
    function LayoutAlgorithm() {
    }
    /// <summary>
    /// Computes bounding rectangle in diagram space using only visible (non-autogenerated boxes).
    /// Useful for rendering the chart, as boxes frequently go into negative side horizontally, and have a special root box on top - all of those should not be accounted for.
    /// </summary>
    LayoutAlgorithm.ComputeBranchVisualBoundingRect = function (visualTree) {
        var result = new Rect_1.default(0, 0, 0, 0);
        var initialized = false;
        if (visualTree.Root == null) {
            throw Error("Root is null");
        }
        visualTree.Root.IterateParentFirst(function (node) {
            var box = node.Element;
            if (!node.State.IsHidden && !box.IsSpecial) {
                if (node.State.Size == null) {
                    throw Error("Size is null");
                }
                if (node.State.TopLeft == null) {
                    throw Error("TopLeft is null");
                }
                if (initialized) {
                    result = Rect_1.default.add(result, Rect_1.default.from(node.State.Size, node.State.TopLeft));
                }
                else {
                    initialized = true;
                    result = Rect_1.default.from(node.State.Size, node.State.TopLeft);
                }
            }
            return !box.IsCollapsed;
        });
        return result;
    };
    /// <summary>
    /// Initializes <paramref name="state"/> and performs all layout operations.
    /// </summary>
    LayoutAlgorithm.Apply = function (state) {
        var e_1, _a, e_2, _b;
        var _c, _d;
        // verify the root
        if (state.Diagram.Boxes && state.Diagram.Boxes.SystemRoot == null) {
            throw new Error("SystemRoot is not initialized on the box container");
        }
        state.CurrentOperation = Operation_1.default.Preparing;
        var tree = BoxTree_1.default.Build(state);
        state.Diagram.VisualTree = tree;
        // verify the root: regardless of data items, there must be a system root box on top of everything
        // the corresponding node is not supposed to be rendered, it only serves as layout algorithm's starting point
        if (tree.Root == null ||
            (state.Diagram.Boxes &&
                tree.Root.Element.Id != ((_c = state.Diagram.Boxes.SystemRoot) === null || _c === void 0 ? void 0 : _c.Id))) {
            throw new Error("SystemRoot is not on the top of the visual tree");
        }
        // set the tree and update visibility
        tree.UpdateHierarchyStats();
        state.AttachVisualTree(tree);
        // update visibility of boxes based on collapsed state
        tree.IterateParentFirst(function (node) {
            node.State.IsHidden =
                node.ParentNode != null &&
                    (node.ParentNode.State.IsHidden || node.ParentNode.Element.IsCollapsed);
            return true;
        });
        // In this phase, we will figure out layout strategy
        // and initialize layout state for each node.
        // Event listener may perform initial rendering /measuring of boxes when this event fires,
        // to determine box sizes and be ready to supply them via BoxSizeFunc delegate.
        state.CurrentOperation = Operation_1.default.PreprocessVisualTree;
        // initialize box sizes
        if (state.BoxSizeFunc != null) {
            try {
                // apply box sizes
                for (var _e = __values(__spread((_d = state.Diagram.Boxes) === null || _d === void 0 ? void 0 : _d.BoxesById.values()).filter(function (x) { return x.IsDataBound; })), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var box = _f.value;
                    box.Size = state.BoxSizeFunc(box.DataId);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        try {
            for (var _g = __values(state.Diagram.Boxes.BoxesById.values()), _h = _g.next(); !_h.done; _h = _g.next()) {
                var box = _h.value;
                this.AssertBoxSize(box);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // initialize layout state on each node
        tree.IterateParentFirst(function (node) {
            LayoutAlgorithm.MoveTo(node.State, 0, 0);
            node.State.Size = node.Element.Size;
            node.State.BranchExterior = Rect_1.default.from(node.Element.Size, new Point_1.default(0, 0));
            return true;
        });
        this.PreprocessVisualTree(state, tree);
        tree.UpdateHierarchyStats();
        state.CurrentOperation = Operation_1.default.VerticalLayout;
        this.VerticalLayout(state, tree.Root);
        state.CurrentOperation = Operation_1.default.HorizontalLayout;
        this.HorizontalLayout(state, tree.Root);
        state.CurrentOperation = Operation_1.default.ConnectorsLayout;
        this.RouteConnectors(state, tree);
        state.CurrentOperation = Operation_1.default.Completed;
    };
    /// <summary>
    /// Ths function helps catch "undefined" values when operating in JavaScript-converted version of this code.
    /// Also, helps catch some bugs in C# version as well.
    /// They way it's implemented has direct impact on how JavaScript validation code looks like, so don't "optimize".
    /// </summary>
    LayoutAlgorithm.AssertBoxSize = function (box) {
        if (box.Size.Width >= 0.0 && box.Size.Width <= 1000000000.0) {
            if (box.Size.Height >= 0.0 && box.Size.Width <= 1000000000.0) {
                return;
            }
        }
        throw new Error("Box " + box.Id + " has invalid size: " + box.Size.Width + "x" + box.Size.Height);
    };
    LayoutAlgorithm.PreprocessVisualTree = function (state, visualTree) {
        var defaultStrategy = state.Diagram.LayoutSettings.RequireDefaultLayoutStrategy();
        var defaultAssistantsStrategy = state.Diagram.LayoutSettings.RequireDefaultAssistantLayoutStrategy();
        var regular = [];
        regular.push(defaultStrategy);
        var assistants = [];
        assistants.push(defaultAssistantsStrategy);
        visualTree.IterateParentFirst(function (node) {
            var _a;
            if (node.State.IsHidden) {
                return false;
            }
            var strategy = null;
            if (state.LayoutOptimizerFunc != null) {
                var suggestedStrategyId = state.LayoutOptimizerFunc(node);
                if (suggestedStrategyId) {
                    strategy = state.Diagram.LayoutSettings.LayoutStrategies.get(suggestedStrategyId);
                    if (process.env.NODE_ENV !== "production") {
                        if (!strategy) {
                            console.info("Invalid strategy:", {
                                suggestedStrategyId: suggestedStrategyId,
                                strategy: strategy,
                            });
                        }
                    }
                }
            }
            if (node.IsAssistantRoot) {
                if (strategy == null) {
                    strategy =
                        ((_a = node.ParentNode) === null || _a === void 0 ? void 0 : _a.Element.AssistantLayoutStrategyId) != null
                            ? state.Diagram.LayoutSettings.LayoutStrategies.get(node.ParentNode.Element.AssistantLayoutStrategyId)
                            : Utils_1.peek(assistants);
                }
                if (strategy == null) {
                    throw Error("Strategy is null. Maybe it allows null?");
                }
                assistants.push(strategy);
            }
            else {
                if (strategy == null) {
                    strategy =
                        node.Element.LayoutStrategyId != null
                            ? state.Diagram.LayoutSettings.LayoutStrategies.get(node.Element.LayoutStrategyId)
                            : Utils_1.peek(regular);
                }
                if (strategy == null) {
                    throw Error("Strategy is null. Maybe it allows null?");
                }
                regular.push(strategy);
                if (!strategy.SupportsAssistants) {
                    node.SuppressAssistants();
                }
            }
            // now let it pre-allocate special boxes etc
            node.State.EffectiveLayoutStrategy = strategy;
            node.State.RequireLayoutStrategy.PreProcessThisNode(state, node);
            return ((!node.Element.IsCollapsed && node.ChildCount > 0) ||
                node.AssistantsRoot != null);
        }, function (node) {
            if (!node.State.IsHidden) {
                if (node.IsAssistantRoot) {
                    assistants.pop();
                }
                else {
                    regular.pop();
                }
            }
        });
    };
    LayoutAlgorithm.HorizontalLayout = function (state, branchRoot) {
        if (branchRoot.State.IsHidden) {
            throw new Error("Branch root " + branchRoot.Element.Id + " does not affect layout");
        }
        var level = state.PushLayoutLevel(branchRoot);
        try {
            if (branchRoot.Level == 0 ||
                ((branchRoot.State.NumberOfSiblings > 0 ||
                    branchRoot.AssistantsRoot != null) &&
                    !branchRoot.Element.IsCollapsed)) {
                branchRoot.State.RequireLayoutStrategy.ApplyHorizontalLayout(state, level);
            }
        }
        finally {
            state.PopLayoutLevel();
        }
    };
    /// <summary>
    /// Re-entrant layout algorithm.
    /// </summary>
    LayoutAlgorithm.VerticalLayout = function (state, branchRoot) {
        if (branchRoot.State.IsHidden) {
            throw new Error("Branch root " + branchRoot.Element.Id + " does not affect layout");
        }
        var level = state.PushLayoutLevel(branchRoot);
        try {
            if (branchRoot.Level == 0 ||
                ((branchRoot.State.NumberOfSiblings > 0 ||
                    branchRoot.AssistantsRoot != null) &&
                    !branchRoot.Element.IsCollapsed)) {
                branchRoot.State.RequireLayoutStrategy.ApplyVerticalLayout(state, level);
            }
        }
        finally {
            state.PopLayoutLevel();
        }
    };
    LayoutAlgorithm.RouteConnectors = function (state, visualTree) {
        visualTree.IterateParentFirst(function (node) {
            if (node.Element.IsCollapsed ||
                (node.State.NumberOfSiblings == 0 && node.AssistantsRoot == null)) {
                return false;
            }
            if (node.Level == 0) {
                return true;
            }
            if (!node.Element.IsSpecial || node.IsAssistantRoot) {
                node.State.RequireLayoutStrategy.RouteConnectors(state, node);
                return true;
            }
            return false;
        });
    };
    /// <summary>
    /// Moves a given branch horizontally, except its root box.
    /// Also updates branch exterior rects.
    /// Also updates branch boundary for the current <paramref name="layoutLevel"/>.
    /// </summary>
    LayoutAlgorithm.MoveChildrenOnly = function (state, layoutLevel, offset) {
        var e_3, _a;
        var children = layoutLevel.BranchRoot.Children;
        if (children == null || children.length == 0) {
            throw new Error("Should never be invoked when children not set");
        }
        var action = function (node) {
            if (!node.State.IsHidden) {
                try {
                    node.State.TopLeft = node.State.TopLeft.MoveH(offset);
                    node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);
                }
                catch (e) {
                    // ignore
                }
            }
            return true;
        };
        try {
            for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                var child = children_1_1.value;
                child.IterateChildFirst(action);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);
        layoutLevel.BranchRoot.State.BranchExterior =
            layoutLevel.Boundary.BoundingRect;
    };
    /// <summary>
    /// Moves a given branch horizontally, except its root box.
    /// Also updates branch exterior rects.
    /// Unlike <see cref="MoveChildrenOnly"/> and <see cref="MoveBranch"/>, does NOT update the boundary.
    /// </summary>
    /// <remarks>DOES NOT update branch boundary! Must call <see cref="Boundary.ReloadFromBranch"/> after batch of updates is complete</remarks>
    LayoutAlgorithm.MoveOneChild = function (state, root, offset) {
        root.IterateChildFirst(function (node) {
            if (!node.State.IsHidden) {
                node.State.TopLeft = node.State.TopLeft.MoveH(offset);
                node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);
            }
            return true;
        });
    };
    /// <summary>
    /// Moves a given branch horizontally, including its root box.
    /// Also updates branch exterior rects.
    /// Also updates branch boundary for the current <paramref name="layoutLevel"/>.
    /// </summary>
    LayoutAlgorithm.MoveBranch = function (state, layoutLevel, offset) {
        this.MoveOneChild(state, layoutLevel.BranchRoot, offset);
        layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);
        layoutLevel.BranchRoot.State.BranchExterior =
            layoutLevel.Boundary.BoundingRect;
    };
    /// <summary>
    /// Vertically aligns a subset of child nodes, presumably located one above another.
    /// All children must belong to the current layout level's root.
    /// Returns leftmost and rightmost boundaries of all branches in the <paramref name="subset"/>, after alignment.
    /// </summary>
    LayoutAlgorithm.AlignHorizontalCenters = function (state, level, subset) {
        var e_4, _a, e_5, _b;
        // compute the rightmost center in the column
        var center = Number.MIN_VALUE;
        try {
            for (var subset_1 = __values(subset), subset_1_1 = subset_1.next(); !subset_1_1.done; subset_1_1 = subset_1.next()) {
                var child = subset_1_1.value;
                var c = child.State.CenterH;
                if (c > center) {
                    center = c;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return)) _a.call(subset_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // move those boxes in the column that are not aligned with the rightmost center
        var leftmost = Number.MAX_VALUE;
        var rightmost = Number.MIN_VALUE;
        try {
            for (var subset_2 = __values(subset), subset_2_1 = subset_2.next(); !subset_2_1.done; subset_2_1 = subset_2.next()) {
                var child = subset_2_1.value;
                var frame = child.State;
                var c_1 = frame.CenterH;
                if (c_1 !== center) {
                    var diff = center - c_1;
                    this.MoveOneChild(state, child, diff);
                }
                leftmost = Math.min(leftmost, child.State.BranchExterior.Left);
                rightmost = Math.max(rightmost, child.State.BranchExterior.Right);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (subset_2_1 && !subset_2_1.done && (_b = subset_2.return)) _b.call(subset_2);
            }
            finally { if (e_5) throw e_5.error; }
        }
        // update branch boundary
        level.Boundary.ReloadFromBranch(level.BranchRoot);
        return new Dimensions_1.default(leftmost, rightmost);
    };
    /// <summary>
    /// Copies vertical and horionztal measurement data from <paramref name="other"/> frame.
    /// Does not copy <see cref="Connector"/>.
    /// </summary>
    LayoutAlgorithm.CopyExteriorFrom = function (state, other) {
        state.TopLeft = other.TopLeft;
        state.Size = other.Size;
        state.BranchExterior = other.BranchExterior;
        state.SiblingsRowV = other.SiblingsRowV;
    };
    /// <summary>
    /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
    /// </summary>
    LayoutAlgorithm.IsMinValue = function (value) {
        return value <= Number.MIN_VALUE + Number.EPSILON;
    };
    /// <summary>
    /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
    /// </summary>
    LayoutAlgorithm.IsMaxValue = function (value) {
        return value >= Number.MAX_VALUE - Number.EPSILON;
    };
    /// <summary>
    /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
    /// </summary>
    LayoutAlgorithm.IsZero = function (value) {
        return value <= Number.EPSILON && value >= -Number.EPSILON;
    };
    /// <summary>
    /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
    /// </summary>
    LayoutAlgorithm.IsEqual = function (value, other) {
        return Math.abs(value - other) <= Number.EPSILON;
    };
    /// <summary>
    /// Changes <see cref="NodeLayoutInfo.TopLeft"/>.
    /// </summary>
    LayoutAlgorithm.MoveTo = function (state, x, y) {
        state.TopLeft = new Point_1.default(x, y);
    };
    /// <summary>
    /// Uitility for special boxes, spacers etc.
    /// Adjusts exterior and resets branch exterior to size.
    /// </summary>
    LayoutAlgorithm.AdjustSpacer = function (state, x, y, w, h) {
        state.TopLeft = new Point_1.default(x, y);
        state.Size = new Size_1.default(w, h);
        state.BranchExterior = new Rect_1.default(x, y, w, h);
    };
    return LayoutAlgorithm;
}());
exports.default = LayoutAlgorithm;
