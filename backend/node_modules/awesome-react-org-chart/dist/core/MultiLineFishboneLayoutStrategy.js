"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var LinearLayoutStrategy_1 = __importDefault(require("./LinearLayoutStrategy"));
var LayoutStrategyBase_1 = __importDefault(require("./LayoutStrategyBase"));
var Node_1 = __importDefault(require("./Node"));
var Box_1 = __importDefault(require("./Box"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var BranchParentAlignment_1 = __importDefault(require("./BranchParentAlignment"));
var Edge_1 = __importDefault(require("./Edge"));
var Point_1 = __importDefault(require("./Point"));
var Connector_1 = __importDefault(require("./Connector"));
var Rect_1 = __importDefault(require("./Rect"));
var ConnectorAlignment_1 = __importDefault(require("./ConnectorAlignment"));
var GroupIterator = /** @class */ (function () {
    function GroupIterator(numberOfSiblings, numberOfGroups) {
        this.Group = 0;
        this.FromIndex = 0;
        this.Count = 0;
        this.MaxOnLeft = 0;
        this._numberOfSiblings = numberOfSiblings;
        this._numberOfGroups = numberOfGroups;
    }
    GroupIterator.prototype.CountInGroup = function () {
        var countInRow = this._numberOfGroups * 2;
        var result = 0;
        var countToThisGroup = this.Group * 2 + 2;
        var firstInRow = 0;
        while (true) {
            var countInThisRow = firstInRow >= this._numberOfSiblings - countInRow
                ? this._numberOfSiblings - firstInRow
                : countInRow;
            if (countInThisRow >= countToThisGroup) {
                result += 2;
            }
            else {
                countToThisGroup--;
                if (countInThisRow >= countToThisGroup) {
                    result++;
                }
                break;
            }
            firstInRow += countInRow;
        }
        return result;
    };
    GroupIterator.prototype.NextGroup = function () {
        this.FromIndex = this.FromIndex + this.Count;
        if (this.FromIndex > 0) {
            this.Group++;
        }
        this.Count = this.CountInGroup();
        this.MaxOnLeft = Math.floor(this.Count / 2) + (this.Count % 2);
        return this.Count != 0;
    };
    return GroupIterator;
}());
var TreeNodeView = /** @class */ (function (_super) {
    __extends(TreeNodeView, _super);
    function TreeNodeView(element) {
        return _super.call(this, element) || this;
    }
    TreeNodeView.prototype.Prepare = function (capacity) {
        if (this.Children == null) {
            this.Children = [];
        }
        else {
            this.Children.length = 0;
        }
    };
    TreeNodeView.prototype.AddChildView = function (node) {
        this.Children.push(node);
    };
    return TreeNodeView;
}(Node_1.default));
var SingleFishboneLayoutAdapter = /** @class */ (function (_super) {
    __extends(SingleFishboneLayoutAdapter, _super);
    function SingleFishboneLayoutAdapter(realRoot) {
        var _this = _super.call(this) || this;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return false; };
        _this.Iterator = new GroupIterator(realRoot.State.NumberOfSiblings, realRoot.State.NumberOfSiblingColumns);
        _this.RealRoot = realRoot;
        _this.SpecialRoot = new TreeNodeView(Box_1.default.Special(Box_1.default.None, realRoot.Element.Id, true));
        (_this.SpecialRoot.Level = _this.RealRoot.Level),
            (_this.SpecialRoot.ParentNode = _this.RealRoot);
        _this.SpecialRoot.State.EffectiveLayoutStrategy = _this;
        var parentStrategy = realRoot.State
            .RequireLayoutStrategy;
        _this.SiblingSpacing = parentStrategy.SiblingSpacing;
        _this.ParentConnectorShield = parentStrategy.ParentConnectorShield;
        _this.ParentChildSpacing = parentStrategy.ParentChildSpacing;
        _this.ParentAlignment = parentStrategy.ParentAlignment;
        _this.ChildConnectorHookLength = parentStrategy.ChildConnectorHookLength;
        return _this;
    }
    SingleFishboneLayoutAdapter.prototype.NextGroup = function () {
        if (!this.Iterator.NextGroup()) {
            return false;
        }
        this.SpecialRoot.State.NumberOfSiblings = this.Iterator.Count;
        this.SpecialRoot.Prepare(this.RealRoot.State.NumberOfSiblingRows * 2);
        for (var i = 0; i < this.Iterator.Count; i++) {
            this.SpecialRoot.AddChildView(this.RealRoot.Children[this.Iterator.FromIndex + i]);
        }
        var spacer = this.RealRoot.Children[this.RealRoot.State.NumberOfSiblings + 1 + this.Iterator.Group];
        this.SpecialRoot.AddChildView(spacer);
        LayoutAlgorithm_1.default.CopyExteriorFrom(this.SpecialRoot.State, this.RealRoot.State);
        return true;
    };
    SingleFishboneLayoutAdapter.prototype.PreProcessThisNode = function (state, node) {
        throw new Error("NotSupportedException");
    };
    SingleFishboneLayoutAdapter.prototype.ApplyVerticalLayout = function (state, level) {
        var _a, _b;
        if (this.SpecialRoot.State.SiblingsRowV == null) {
            throw Error("SiblingsRowV is null");
        }
        var prevRowBottom = (_b = (_a = this.RealRoot.AssistantsRoot) === null || _a === void 0 ? void 0 : _a.State.BranchExterior.Bottom) !== null && _b !== void 0 ? _b : this.SpecialRoot.State.SiblingsRowV.To;
        for (var i = 0; i < this.Iterator.MaxOnLeft; i++) {
            var spacing = i == 0 ? this.ParentChildSpacing : this.SiblingSpacing;
            var child = this.SpecialRoot.Children[i];
            var frame = child.State;
            LayoutAlgorithm_1.default.MoveTo(frame, frame.Left, prevRowBottom + spacing);
            var rowExterior = new Dimensions_1.default(frame.Top, frame.Bottom);
            var i2 = i + this.Iterator.MaxOnLeft;
            if (frame.Size == null) {
                throw Error("Size is null");
            }
            if (i2 < this.Iterator.Count) {
                var child2 = this.SpecialRoot.Children[i2];
                var frame2 = child2.State;
                LayoutAlgorithm_1.default.MoveTo(frame2, frame2.Left, prevRowBottom + spacing);
                if (frame2.Size == null) {
                    throw Error("Size is null");
                }
                if (frame2.Bottom > frame.Bottom) {
                    LayoutAlgorithm_1.default.MoveTo(frame, frame.Left, frame2.CenterV - frame.Size.Height / 2);
                }
                else if (frame2.Bottom < frame.Bottom) {
                    LayoutAlgorithm_1.default.MoveTo(frame2, frame2.Left, frame.CenterV - frame2.Size.Height / 2);
                }
                frame2.BranchExterior = Rect_1.default.from(frame2.Size, frame2.TopLeft);
                rowExterior = Dimensions_1.default.add(rowExterior, new Dimensions_1.default(frame2.Top, frame2.Bottom));
                frame2.SiblingsRowV = rowExterior;
                LayoutAlgorithm_1.default.VerticalLayout(state, child2);
                prevRowBottom = frame2.BranchExterior.Bottom;
            }
            frame.BranchExterior = Rect_1.default.from(frame.Size, frame.TopLeft);
            frame.SiblingsRowV = rowExterior;
            LayoutAlgorithm_1.default.VerticalLayout(state, child);
            prevRowBottom = Math.max(prevRowBottom, frame.BranchExterior.Bottom);
        }
    };
    SingleFishboneLayoutAdapter.prototype.ApplyHorizontalLayout = function (state, level) {
        if (level.BranchRoot != this.SpecialRoot) {
            throw new Error("InvalidOperationException: Wrong root node received");
        }
        var left = true;
        var countOnThisSide = 0;
        for (var i = 0; i < this.Iterator.Count; i++) {
            var child = this.SpecialRoot.Children[i];
            LayoutAlgorithm_1.default.HorizontalLayout(state, child);
            // we go top-bottom to layout left side of the group,
            // then add a carrier protector
            // then top-bottom to fill right side of the group
            if (++countOnThisSide == this.Iterator.MaxOnLeft) {
                if (left) {
                    // horizontally align children in left pillar
                    LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateSiblings(0, this.Iterator.MaxOnLeft));
                    left = false;
                    countOnThisSide = 0;
                    var rightmost = Number.MIN_VALUE;
                    for (var k = 0; k < i; k++) {
                        rightmost = Math.max(rightmost, this.SpecialRoot.Children[k].State.BranchExterior.Right);
                    }
                    rightmost = Math.max(rightmost, child.State.Right);
                    // integrate protector for group's vertical carrier
                    var spacer = this.SpecialRoot.Children[this.SpecialRoot.State.NumberOfSiblings];
                    if (this.SpecialRoot.Children[0].State.SiblingsRowV == null) {
                        throw Error("SiblingsRowV is null");
                    }
                    if (child.State.SiblingsRowV == null) {
                        throw Error("SiblingsRowV is null");
                    }
                    LayoutAlgorithm_1.default.AdjustSpacer(spacer.State, rightmost, this.SpecialRoot.Children[0].State.SiblingsRowV.From, this.SiblingSpacing, child.State.SiblingsRowV.To -
                        this.SpecialRoot.Children[0].State.SiblingsRowV.From);
                    level.Boundary.MergeFromNode(spacer);
                }
            }
        }
        // horizontally align children in right pillar
        LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateSiblings(this.Iterator.MaxOnLeft, this.Iterator.Count));
    };
    SingleFishboneLayoutAdapter.prototype.EnumerateSiblings = function (from, to) {
        var nodes = [];
        for (var i = from; i < to; i++) {
            nodes.push(this.SpecialRoot.Children[i]);
        }
        return nodes;
    };
    SingleFishboneLayoutAdapter.prototype.RouteConnectors = function (state, node) {
        throw new Error();
    };
    return SingleFishboneLayoutAdapter;
}(LayoutStrategyBase_1.default));
var MultiLineFishboneLayoutStrategy = /** @class */ (function (_super) {
    __extends(MultiLineFishboneLayoutStrategy, _super);
    function MultiLineFishboneLayoutStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /// <summary>
        /// Maximum number of boxes staffed onto a single vertical carrier.
        /// </summary>
        _this.MaxGroups = 4;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return true; };
        return _this;
        /// <summary>
        /// Implements layout for a single vertically stretched fishbone.
        /// Re-used by <see cref="MultiLineFishboneLayoutStrategy"/> to layout multiple groups of siblings.
        /// </summary>
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// </summary>
    MultiLineFishboneLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        if (this.MaxGroups <= 0) {
            throw new Error("MaxGroups must be a positive value");
        }
        if (node.ChildCount <= this.MaxGroups * 2) {
            _super.prototype.PreProcessThisNode.call(this, state, node);
            return;
        }
        node.State.NumberOfSiblings = node.ChildCount;
        // only add spacers for non-collapsed boxes
        if (node.State.NumberOfSiblings > 0) {
            // using column == group here,
            // and each group consists of two vertical stretches of boxes with a vertical carrier in between
            node.State.NumberOfSiblingColumns = this.MaxGroups;
            node.State.NumberOfSiblingRows = Math.floor(node.State.NumberOfSiblings / (this.MaxGroups * 2));
            if (node.State.NumberOfSiblings % (this.MaxGroups * 2) != 0) {
                node.State.NumberOfSiblingRows++;
            }
            // a connector from parent to horizontal carrier
            var parentSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
            node.AddRegularChildBox(parentSpacer);
            // spacers for vertical carriers
            for (var i = 0; i < node.State.NumberOfSiblingColumns; i++) {
                var verticalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.AddRegularChildBox(verticalSpacer);
            }
            // if needed, horizontal carrier
            if (node.State.NumberOfSiblingColumns > 1) {
                var horizontalSpacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
                node.AddRegularChildBox(horizontalSpacer);
            }
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    MultiLineFishboneLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {
            _super.prototype.ApplyVerticalLayout.call(this, state, level);
            return;
        }
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.AssistantsRoot != null) {
            // assistants root has to be initialized with main node's exterior
            LayoutAlgorithm_1.default.CopyExteriorFrom(node.AssistantsRoot.State, node.State);
            LayoutAlgorithm_1.default.VerticalLayout(state, node.AssistantsRoot);
        }
        var adapter = new SingleFishboneLayoutAdapter(node);
        while (adapter.NextGroup()) {
            LayoutAlgorithm_1.default.VerticalLayout(state, adapter.SpecialRoot);
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    MultiLineFishboneLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {
            _super.prototype.ApplyHorizontalLayout.call(this, state, level);
            return;
        }
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        if (node.AssistantsRoot != null) {
            LayoutAlgorithm_1.default.HorizontalLayout(state, node.AssistantsRoot);
        }
        var adapter = new SingleFishboneLayoutAdapter(node);
        while (adapter.NextGroup()) {
            LayoutAlgorithm_1.default.HorizontalLayout(state, adapter.SpecialRoot);
        }
        var rect = node.State;
        // now align child nodes under the parent
        if (node.Level > 0) {
            var diff = 0;
            if (node.State.NumberOfSiblingColumns > 1) {
                var leftCarrier = node.Children[node.State.NumberOfSiblings + 1].State.CenterH;
                var rightCarrier = node.Children[node.State.NumberOfSiblings + node.State.NumberOfSiblingColumns].State.CenterH;
                var desiredCenter = node.State.NumberOfSiblings == 1 ||
                    this.ParentAlignment == BranchParentAlignment_1.default.Center
                    ? leftCarrier + (rightCarrier - leftCarrier) / 2
                    : this.ParentAlignment == BranchParentAlignment_1.default.Left
                        ? leftCarrier + this.ChildConnectorHookLength
                        : rightCarrier - this.ChildConnectorHookLength;
                //let desiredCenter = (leftCarrier + rightCarrier)/2.0;
                diff = rect.CenterH - desiredCenter;
            }
            else {
                var carrier = node.Children[1 + node.State.NumberOfSiblings].State.CenterH;
                var desiredCenter = rect.CenterH;
                diff = desiredCenter - carrier;
            }
            LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
        }
        if (node.Level > 0) {
            if (node.Children[0].State.SiblingsRowV == null) {
                throw Error("SiblingsRowV is null");
            }
            // vertical connector from parent
            var ix = node.State.NumberOfSiblings;
            var verticalSpacer = node.Children[ix];
            LayoutAlgorithm_1.default.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);
            state.MergeSpacer(verticalSpacer);
            ix++;
            // vertical carriers already merged in
            ix += node.State.NumberOfSiblingColumns;
            if (node.State.NumberOfSiblingColumns > 1) {
                // have a horizontal carrier
                var horizontalSpacer = node.Children[ix];
                var leftmost = node.Children[node.State.NumberOfSiblings + 1].State.TopLeft;
                var rightmost = node.Children[ix - 1].State.Right;
                LayoutAlgorithm_1.default.AdjustSpacer(horizontalSpacer.State, leftmost.X, leftmost.Y - this.ParentChildSpacing, rightmost - leftmost.X, this.ParentChildSpacing);
                state.MergeSpacer(horizontalSpacer);
            }
        }
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    MultiLineFishboneLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {
            _super.prototype.RouteConnectors.call(this, state, node);
            return;
        }
        var count = 1 + // one parent connector
            node.State.NumberOfSiblings + // one hook for each child
            node.State.NumberOfSiblingColumns; // one for each vertical carrier
        if (node.State.NumberOfSiblingColumns > 1) {
            // also have a horizontal carrier
            count++;
        }
        var segments = [];
        var rootRect = node.State;
        var center = rootRect.CenterH;
        var ix = 0;
        if (node.Children[0].State.SiblingsRowV == null) {
            throw Error("SiblingsRowV is null");
        }
        var rootRectV = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
            ? rootRect.CenterV
            : rootRect.Bottom;
        // parent connector
        var space = node.Children[0].State.SiblingsRowV.From - rootRectV;
        segments[ix++] = new Edge_1.default(new Point_1.default(center, rootRectV), new Point_1.default(center, rootRectV + space - this.ChildConnectorHookLength));
        // one hook for each child
        var iterator = new GroupIterator(node.State.NumberOfSiblings, node.State.NumberOfSiblingColumns);
        while (iterator.NextGroup()) {
            var carrier = node.Children[1 + node.State.NumberOfSiblings + iterator.Group].State;
            var from = carrier.CenterH;
            var isLeft = true;
            var countOnThisSide = 0;
            for (var i = iterator.FromIndex; i < iterator.FromIndex + iterator.Count; i++) {
                var to = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                    ? node.Children[i].State.CenterH
                    : isLeft
                        ? node.Children[i].State.Right
                        : node.Children[i].State.Left;
                var y = node.Children[i].State.CenterV - this.ConnectorThickness;
                segments[ix++] = new Edge_1.default(new Point_1.default(from, y), new Point_1.default(to, y));
                if (++countOnThisSide == iterator.MaxOnLeft) {
                    countOnThisSide = 0;
                    if (isLeft) {
                        // one for each vertical carrier
                        segments[1 + node.State.NumberOfSiblings + iterator.Group] = new Edge_1.default(new Point_1.default(carrier.CenterH, carrier.Top - this.ChildConnectorHookLength), new Point_1.default(carrier.CenterH, node.Children[i].State.CenterV));
                    }
                    isLeft = !isLeft;
                }
            }
        }
        // vertical carriers already created
        ix += node.State.NumberOfSiblingColumns;
        if (node.State.NumberOfSiblingColumns > 1) {
            var leftGroup = node.Children[1 + node.State.NumberOfSiblings].State;
            var rightGroup = node.Children[1 +
                node.State.NumberOfSiblings +
                node.State.NumberOfSiblingColumns -
                1].State;
            // one horizontal carrier
            segments[ix] = new Edge_1.default(new Point_1.default(leftGroup.CenterH, leftGroup.Top - this.ChildConnectorHookLength), new Point_1.default(rightGroup.CenterH, rightGroup.Top - this.ChildConnectorHookLength));
        }
        node.State.Connector = new Connector_1.default(segments);
    };
    return MultiLineFishboneLayoutStrategy;
}(LinearLayoutStrategy_1.default));
exports.default = MultiLineFishboneLayoutStrategy;
