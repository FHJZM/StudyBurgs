"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = __importDefault(require("./Operation"));
var LayoutStateOperationChangedEventArgs_1 = __importDefault(require("./LayoutStateOperationChangedEventArgs"));
var Boundary_1 = __importDefault(require("./Boundary"));
var LayoutLevel_1 = __importDefault(require("./LayoutLevel"));
var BoundaryChangedEventArgs_1 = __importDefault(require("./BoundaryChangedEventArgs"));
var Rect_1 = __importDefault(require("./Rect"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var Utils_1 = require("./Utils");
var LayoutState = /** @class */ (function () {
    function LayoutState(diagram) {
        this._currentOperation = Operation_1.default.Idle;
        this._layoutStack = [];
        this._pooledBoundaries = [];
        this.BoxSizeFunc = null;
        this.LayoutOptimizerFunc = null;
        this.BoundaryChanged = null;
        this.OperationChanged = null;
        this.Diagram = diagram;
    }
    Object.defineProperty(LayoutState.prototype, "CurrentOperation", {
        get: function () {
            return this._currentOperation;
        },
        set: function (value) {
            this._currentOperation = value;
            if (this.OperationChanged) {
                this.OperationChanged(this, new LayoutStateOperationChangedEventArgs_1.default(this));
            }
        },
        enumerable: false,
        configurable: true
    });
    /// <summary>
    /// Initializes the visual tree and pool of boundary objects.
    /// </summary>
    LayoutState.prototype.AttachVisualTree = function (tree) {
        while (this._pooledBoundaries.length < tree.Depth) {
            this._pooledBoundaries.push(new Boundary_1.default());
        }
    };
    LayoutState.prototype.PushLayoutLevel = function (node) {
        if (this._pooledBoundaries.length == 0) {
            this._pooledBoundaries.push(new Boundary_1.default());
        }
        var boundary = this._pooledBoundaries.pop();
        if (boundary == null) {
            throw Error("Boundary is null");
        }
        switch (this.CurrentOperation) {
            case Operation_1.default.VerticalLayout:
                boundary.Prepare(node);
                break;
            case Operation_1.default.HorizontalLayout:
                boundary.PrepareForHorizontalLayout(node);
                break;
            default:
                throw new Error("This operation can only be invoked when performing vertical or horizontal layouts");
        }
        if (boundary == null) {
            throw Error("Boundary cannot be null");
        }
        var result = new LayoutLevel_1.default(node, boundary);
        this._layoutStack.push(result);
        if (this.BoundaryChanged) {
            this.BoundaryChanged(this, new BoundaryChangedEventArgs_1.default(boundary, result, this));
        }
        return result;
    };
    LayoutState.prototype.MergeSpacer = function (spacer) {
        if (this.CurrentOperation != Operation_1.default.HorizontalLayout) {
            throw new Error("Spacers can only be merged during horizontal layout");
        }
        if (this._layoutStack.length == 0) {
            throw new Error("Cannot merge spacers at top nesting level");
        }
        var level = Utils_1.peek(this._layoutStack);
        if (level == null) {
            throw Error("Level is null");
        }
        level.Boundary.MergeFromNode(spacer);
        if (this.BoundaryChanged) {
            this.BoundaryChanged(this, new BoundaryChangedEventArgs_1.default(level.Boundary, level, this));
        }
    };
    LayoutState.prototype.PopLayoutLevel = function () {
        var innerLevel = this._layoutStack.pop();
        if (innerLevel == null) {
            throw Error("innerLevel is null");
        }
        if (this.BoundaryChanged) {
            this.BoundaryChanged(this, new BoundaryChangedEventArgs_1.default(innerLevel.Boundary, innerLevel, this));
        }
        // if this was not the root, merge boundaries into current level
        if (this._layoutStack.length > 0) {
            var higherLevel = Utils_1.peek(this._layoutStack);
            if (higherLevel == null) {
                throw Error("higherLevel is null");
            }
            switch (this.CurrentOperation) {
                case Operation_1.default.VerticalLayout:
                    higherLevel.Boundary.VerticalMergeFrom(innerLevel.Boundary);
                    higherLevel.BranchRoot.State.BranchExterior =
                        higherLevel.Boundary.BoundingRect;
                    break;
                case Operation_1.default.HorizontalLayout:
                    {
                        // do not apply overlap adjustment for assistant branch, they are always above regular children
                        if (higherLevel.BranchRoot.AssistantsRoot != innerLevel.BranchRoot) {
                            var strategy = higherLevel.BranchRoot.State.RequireLayoutStrategy;
                            var overlap = higherLevel.Boundary.ComputeOverlap(innerLevel.Boundary, strategy.SiblingSpacing, this.Diagram.LayoutSettings.BranchSpacing);
                            if (overlap > 0) {
                                LayoutAlgorithm_1.default.MoveBranch(this, innerLevel, overlap);
                                if (this.BoundaryChanged) {
                                    this.BoundaryChanged(this, new BoundaryChangedEventArgs_1.default(innerLevel.Boundary, innerLevel, this));
                                }
                            }
                        }
                        higherLevel.Boundary.MergeFrom(innerLevel.Boundary);
                        // Do not update branch vertical measurements from the boundary, because boundary adds children one-by-one.
                        // If we take it from boundary, then branch vertical measurement will be incorrect until all children are laid out horizontally,
                        // and this temporarily incorrect state will break those algorithms that need to know combined branch height.
                        higherLevel.BranchRoot.State.BranchExterior = new Rect_1.default(higherLevel.Boundary.BoundingRect.Left, higherLevel.BranchRoot.State.BranchExterior.Top, higherLevel.Boundary.BoundingRect.Size.Width, higherLevel.BranchRoot.State.BranchExterior.Size.Height);
                    }
                    break;
                default:
                    throw new Error("This operation can only be invoked when performing vertical or horizontal layouts");
            }
            if (this.BoundaryChanged) {
                this.BoundaryChanged(this, new BoundaryChangedEventArgs_1.default(higherLevel.Boundary, higherLevel, this));
            }
        }
        // return boundary to the pool
        this._pooledBoundaries.push(innerLevel.Boundary);
    };
    return LayoutState;
}());
exports.default = LayoutState;
