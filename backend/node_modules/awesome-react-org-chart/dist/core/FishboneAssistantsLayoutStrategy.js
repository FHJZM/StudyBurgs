"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var LayoutStrategyBase_1 = __importDefault(require("./LayoutStrategyBase"));
var Box_1 = __importDefault(require("./Box"));
var Dimensions_1 = __importDefault(require("./Dimensions"));
var LayoutAlgorithm_1 = __importDefault(require("./LayoutAlgorithm"));
var Rect_1 = __importDefault(require("./Rect"));
var Edge_1 = __importDefault(require("./Edge"));
var Point_1 = __importDefault(require("./Point"));
var Connector_1 = __importDefault(require("./Connector"));
var ConnectorAlignment_1 = __importDefault(require("./ConnectorAlignment"));
var FishboneAssistantsLayoutStrategy = /** @class */ (function (_super) {
    __extends(FishboneAssistantsLayoutStrategy, _super);
    function FishboneAssistantsLayoutStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /// <summary>
        /// <c>true</c> if this strategy supports special layout for assistant boxes.
        /// If not, assistants will be processed as part of normal children group.
        /// </summary>
        _this.GetSupportsAssistants = function () { return false; };
        _this.MaxOnLeft = function (node) {
            return Math.floor(node.State.NumberOfSiblings / 2) +
                (node.State.NumberOfSiblings % 2);
        };
        _this.NeedCarrierProtector = function (node) { var _a; return ((_a = node.ParentNode) === null || _a === void 0 ? void 0 : _a.ChildCount) == 0; };
        return _this;
    }
    /// <summary>
    /// A chance for layout strategy to append special auto-generated boxes into the visual tree.
    /// </summary>
    FishboneAssistantsLayoutStrategy.prototype.PreProcessThisNode = function (state, node) {
        node.State.NumberOfSiblings = node.ChildCount;
        // only add spacers for non-collapsed boxes
        if (node.State.NumberOfSiblings > 0) {
            // using column == group here,
            // and each group consists of two vertical stretches of boxes with a vertical carrier in between
            node.State.NumberOfSiblingColumns = 1;
            node.State.NumberOfSiblingRows = Math.floor(node.State.NumberOfSiblings / 2);
            if (node.State.NumberOfSiblings % 2 != 0) {
                node.State.NumberOfSiblingRows++;
            }
            // a vertical carrier from parent
            var spacer = Box_1.default.Special(Box_1.default.None, node.Element.Id, false);
            node.AddRegularChildBox(spacer);
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    FishboneAssistantsLayoutStrategy.prototype.ApplyVerticalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.Level == 0) {
            throw new Error("Should never be invoked on root node");
        }
        if (node.State.SiblingsRowV == null) {
            throw Error("SiblingsRowV is null");
        }
        var prevRowBottom = node.State.SiblingsRowV.To;
        var maxOnLeft = this.MaxOnLeft(node);
        for (var i = 0; i < maxOnLeft; i++) {
            var spacing = i == 0 ? this.ParentChildSpacing : this.SiblingSpacing;
            var child = node.Children[i];
            var frame = child.State;
            LayoutAlgorithm_1.default.MoveTo(frame, frame.Left, prevRowBottom + spacing);
            var rowExterior = new Dimensions_1.default(frame.Top, frame.Bottom);
            var i2 = i + maxOnLeft;
            if (frame.Size == null) {
                throw Error("Size is null");
            }
            if (i2 < node.State.NumberOfSiblings) {
                var child2 = node.Children[i2];
                var frame2 = child2.State;
                LayoutAlgorithm_1.default.MoveTo(frame2, frame2.Left, prevRowBottom + spacing);
                if (frame2.Size == null) {
                    throw Error("Size is null");
                }
                if (frame2.Bottom > frame.Bottom) {
                    LayoutAlgorithm_1.default.MoveTo(frame, frame.Left, frame2.CenterV - frame.Size.Height / 2);
                }
                else if (frame2.Bottom < frame.Bottom) {
                    LayoutAlgorithm_1.default.MoveTo(frame2, frame2.Left, frame.CenterV - frame2.Size.Height / 2);
                }
                frame2.BranchExterior = Rect_1.default.from(frame2.Size, frame2.TopLeft);
                rowExterior = Dimensions_1.default.add(rowExterior, new Dimensions_1.default(frame2.Top, frame2.Bottom));
                frame2.SiblingsRowV = rowExterior;
                LayoutAlgorithm_1.default.VerticalLayout(state, child2);
                prevRowBottom = frame2.BranchExterior.Bottom;
            }
            frame.BranchExterior = Rect_1.default.from(frame.Size, frame.TopLeft);
            frame.SiblingsRowV = rowExterior;
            LayoutAlgorithm_1.default.VerticalLayout(state, child);
            prevRowBottom = Math.max(prevRowBottom, frame.BranchExterior.Bottom);
        }
    };
    /// <summary>
    /// Applies layout changes to a given box and its children.
    /// </summary>
    FishboneAssistantsLayoutStrategy.prototype.ApplyHorizontalLayout = function (state, level) {
        var node = level.BranchRoot;
        if (node.Level == 0) {
            node.State.SiblingsRowV = new Dimensions_1.default(node.State.Top, node.State.Bottom);
        }
        var left = true;
        var countOnThisSide = 0;
        var maxOnLeft = this.MaxOnLeft(node);
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var child = node.Children[i];
            LayoutAlgorithm_1.default.HorizontalLayout(state, child);
            // we go top-bottom to layout left side of the group,
            // then add a carrier protector
            // then top-bottom to fill right side of the group
            if (++countOnThisSide == maxOnLeft) {
                if (left) {
                    // horizontally align children in left pillar
                    LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateSiblings(node, 0, maxOnLeft));
                    left = false;
                    countOnThisSide = 0;
                    var rightmost = Number.MIN_VALUE;
                    for (var k = 0; k <= i; k++) {
                        rightmost = Math.max(rightmost, node.Children[k].State.BranchExterior.Right);
                    }
                    // vertical spacer does not have to be extended to the bottom of the lowest branch,
                    // unless the lowest branch on the right side has some children and is expanded
                    if (node.State.NumberOfSiblings % 2 != 0) {
                        rightmost = Math.max(rightmost, child.State.Right);
                    }
                    else {
                        var opposite = node.Children[node.State.NumberOfSiblings - 1];
                        if (opposite.Element.IsCollapsed || opposite.ChildCount == 0) {
                            rightmost = Math.max(rightmost, child.State.Right);
                        }
                        else {
                            rightmost = Math.max(rightmost, child.State.BranchExterior.Right);
                        }
                    }
                    // integrate protector for group's vertical carrier
                    // it must prevent boxes on the right side from overlapping the middle vertical connector,
                    // so protector's height must be set to height of this entire assistant branch
                    var spacer = node.Children[node.State.NumberOfSiblings];
                    LayoutAlgorithm_1.default.AdjustSpacer(spacer.State, rightmost, node.State.Bottom, this.ParentConnectorShield, node.State.BranchExterior.Bottom - node.State.Bottom);
                    level.Boundary.MergeFromNode(spacer);
                }
            }
        }
        // horizontally align children in right pillar
        LayoutAlgorithm_1.default.AlignHorizontalCenters(state, level, this.EnumerateSiblings(node, maxOnLeft, node.State.NumberOfSiblings));
        // align children under parent
        if (node.Level > 0 && node.State.NumberOfSiblings > 0) {
            var carrier = node.Children[node.State.NumberOfSiblings].State.CenterH;
            var desiredCenter = node.State.CenterH;
            var diff = desiredCenter - carrier;
            LayoutAlgorithm_1.default.MoveChildrenOnly(state, level, diff);
        }
    };
    /// <summary>
    /// Allocates and routes connectors.
    /// </summary>
    FishboneAssistantsLayoutStrategy.prototype.RouteConnectors = function (state, node) {
        var count = node.State.NumberOfSiblings;
        if (count == 0) {
            return;
        }
        if (this.NeedCarrierProtector(node)) {
            count++;
        }
        var segments = [];
        var ix = 0;
        // one hook for each child
        var maxOnLeft = this.MaxOnLeft(node);
        var carrier = node.Children[node.State.NumberOfSiblings].State;
        var from = carrier.CenterH;
        var isLeft = true;
        var countOnThisSide = 0;
        var bottomMost = Number.MIN_VALUE;
        for (var i = 0; i < node.State.NumberOfSiblings; i++) {
            var to = this.ConnectorAlignment === ConnectorAlignment_1.default.Center
                ? node.Children[i].State.CenterH
                : isLeft
                    ? node.Children[i].State.Right
                    : node.Children[i].State.Left;
            var y = node.Children[i].State.CenterV;
            bottomMost = Math.max(bottomMost, y);
            segments[ix++] = new Edge_1.default(new Point_1.default(from, y), new Point_1.default(to, y));
            if (++countOnThisSide == maxOnLeft) {
                countOnThisSide = 0;
                isLeft = !isLeft;
            }
        }
        if (this.NeedCarrierProtector(node)) {
            // one for each vertical carrier
            segments[node.State.NumberOfSiblings] = new Edge_1.default(new Point_1.default(carrier.CenterH, carrier.Top), new Point_1.default(carrier.CenterH, bottomMost));
        }
        node.State.Connector = new Connector_1.default(segments);
    };
    FishboneAssistantsLayoutStrategy.prototype.EnumerateSiblings = function (node, from, to) {
        var nodes = [];
        for (var i = from; i < to; i++) {
            nodes.push(node.Children[i]);
        }
        return nodes;
    };
    return FishboneAssistantsLayoutStrategy;
}(LayoutStrategyBase_1.default));
exports.default = FishboneAssistantsLayoutStrategy;
